<!-- CW Call Sign Trainer
Author: Matthew Swint, K2MAS
License: GPLv3 -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CW Call Sign Trainer with Iambic Keyer</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111827;
      color: #e5e7eb;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    header {
      text-align: center;
      padding: 1rem 1rem 0.5rem;
    }
    header h1 {
      margin: 0;
      font-size: 1.8rem;
      color: #fbbf24;
    }
    header p {
      margin: 0.3rem 0;
      color: #9ca3af;
      font-size: 0.95rem;
    }
    .panel {
      background: #020617;
      border-radius: 0.75rem;
      padding: 1.25rem 1.5rem;
      margin: 0.75rem 0;
      width: 95%;
      max-width: 850px;
      box-sizing: border-box;
      box-shadow: 0 10px 25px rgba(0,0,0,0.35);
      border: 1px solid #1f2937;
    }
    .header-panel {
      text-align: center;
    }
    .callsign {
      font-size: 3rem;
      font-weight: 700;
      letter-spacing: 0.25em;
      color: #f9fafb;
    }
    .status {
      margin-top: 0.5rem;
      font-size: 0.95rem;
      color: #9ca3af;
    }
    .correct {
      color: #22c55e;
      font-weight: 600;
    }
    .wrong {
      color: #f97316;
      font-weight: 600;
    }
    .io-value {
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 1.1rem;
      min-height: 1.4rem;
      white-space: pre-wrap;
      word-break: break-all;
      color: #e5e7eb;
    }
    .io-value strong {
      color: #fbbf24;
      font-weight: 600;
    }
    .section-title {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: #9ca3af;
      margin-bottom: 0.4rem;
    }
    .hint {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 0.3rem;
    }
    .flex-row {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
    }
    .flex-col {
      flex: 1 1 200px;
      min-width: 0;
    }
    .controls label {
      display: block;
      margin-top: 10px;
      font-size: 0.95rem;
    }
    input[type="range"] {
      width: 200px;
      vertical-align: middle;
    }
    input[type="number"] {
      width: 60px;
      margin-left: 8px;
      padding: 2px 4px;
      background: #020617;
      border: 1px solid #374151;
      color: #e5e7eb;
      border-radius: 4px;
    }
    select {
      margin-left: 8px;
      padding: 2px 4px;
      background: #020617;
      border: 1px solid #374151;
      color: #e5e7eb;
      border-radius: 4px;
    }
    .btn-row {
      margin-top: 12px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    button {
      border-radius: 9999px;
      border: 1px solid #374151;
      background: #111827;
      color: #e5e7eb;
      padding: 6px 14px;
      font-size: 0.9rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      transition: background 0.12s ease, transform 0.08s ease, box-shadow 0.1s ease;
      box-shadow: 0 4px 10px rgba(0,0,0,0.35);
    }
    button:hover {
      background: #1f2937;
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(0,0,0,0.4);
    }
    button:active {
      transform: translateY(0);
      box-shadow: 0 3px 8px rgba(0,0,0,0.3);
    }
    .primary {
      background: #22c55e;
      color: #022c22;
      border-color: #16a34a;
      box-shadow: 0 6px 16px rgba(34,197,94,0.45);
    }
    .primary:hover {
      background: #16a34a;
    }
    .focus-status {
      font-size: 0.8rem;
      margin-top: 0.35rem;
    }
    .focus-warning {
      color: #f97316;
    }
    .focus-ok {
      color: #22c55e;
    }
    footer {
      font-size: 0.75rem;
      color: #4b5563;
      padding: 0.5rem 1rem 1rem;
      text-align: center;
    }
  </style>
</head>
<body>
  <header>
    <h1>CW Call Sign Sending Trainer</h1>
    <p>Compatible with the hamradio.solutions paddle adapter.</p>
  </header>

  <div class="panel header-panel">
    <div class="section-title">Current call sign</div>
    <div id="callsign" class="callsign">Loading…</div>
    <div id="status" class="status">Send the call sign using your paddle.</div>
    <div id="focusStatus" class="focus-status focus-warning">
      Click anywhere on this page so it can receive key events.
    </div>
  </div>

  <div class="panel">
    <div class="flex-row">
      <div class="flex-col">
        <div class="section-title">Decoded text</div>
        <div id="decodedText" class="io-value"></div>
        <div class="hint">Your letters as the app decodes them.</div>
      </div>
      <div class="flex-col">
        <div class="section-title">Current Morse pattern</div>
        <div id="pattern" class="io-value"><strong>Waiting for input…</strong></div>
        <div class="hint">Dot = left paddle, Dash = right paddle.</div>
      </div>
    </div>
  </div>

  <div class="btn-row">
      <button id="nextBtn" class="primary">Next call sign</button>
      <button id="resetBtn">Reset decoded text</button>
    </div>
  </div>

  <div class="panel controls">
    <div class="flex-row">
      <div class="flex-col">
        <label>
          WPM:
          <input type="range" id="wpmSlider" min="5" max="40" value="20">
          <input type="number" id="wpmNumber" min="5" max="40" value="20">
        </label>

        <label>
          Iambic mode:
          <select id="iambicMode">
            <option value="A">Mode A</option>
            <option value="B">Mode B</option>
          </select>
        </label>

        <label>
          Sidetone (Hz):
          <input type="range" id="stSlider" min="350" max="900" value="650">
          <input type="number" id="stNumber" min="350" max="900" value="650">
        </label>

        <label>
          Sidetone volume:
          <input type="range" id="toneVolume" min="0" max="1" step="0.01" value="0.3">
        </label>
      </div>
      <div class="flex-col">
        <div class="section-title">Hints</div>
        <p style="font-size:0.85rem; color:#9ca3af; margin-top:4px;">
          • Left paddle (ControlLeft) = dit<br>
          • Right paddle (ControlRight) = dah<br>
          • Hold paddles for iambic sending (A or B).<br>
          • Adjust WPM to match your normal sending speed.
        </p>
      </div>
    </div>

  <footer>
    Made with dits and dahs by Matthew Swint, K2MAS<br />
    version 0.5a
  </footer>

  <script>
    /* ============================================================
       SIDETONE AUDIO (650 Hz default)
       ============================================================ */
    let audioCtx = null;
    let osc = null;
    let gainNode = null;
    let stFreq = 650; // default

    function ensureAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        gainNode = audioCtx.createGain();
        gainNode.gain.value = 0;
        gainNode.connect(audioCtx.destination);
      }
      if (audioCtx.state === "suspended") {
        audioCtx.resume();
      }
      if (!osc) {
        osc = audioCtx.createOscillator();
        osc.frequency.setTargetAtTime(stFreq, audioCtx.currentTime, 0.005);
        osc.type = "sine";
        osc.connect(gainNode);
        osc.start();
      }
    }

    function startTone() {
      ensureAudio();
      const vol = parseFloat(document.getElementById("toneVolume").value);
      const t = audioCtx.currentTime;
      gainNode.gain.cancelScheduledValues(t);
      gainNode.gain.setTargetAtTime(vol, t, 0.003);
    }

    function stopTone() {
      if (!audioCtx || !gainNode) return;
      const t = audioCtx.currentTime;
      gainNode.gain.cancelScheduledValues(t);
      gainNode.gain.setTargetAtTime(0, t, 0.003);
    }

    /* ============================================================
       MORSE TABLE
       ============================================================ */
    const MORSE = {
      A: ".-", B: "-...", C: "-.-.", D: "-..", E: ".", F: "..-.",
      G: "--.", H: "....", I: "..", J: ".---", K: "-.-", L: ".-..",
      M: "--", N: "-.", O: "---", P: ".--.", Q: "--.-", R: ".-.",
      S: "...", T: "-", U: "..-", V: "...-", W: ".--", X: "-..-",
      Y: "-.--", Z: "--..",
      0: "-----", 1: ".----", 2: "..---", 3: "...--", 4: "....-",
      5: ".....", 6: "-....", 7: "--...", 8: "---..", 9: "----."
      //,?: "..--..", /: "-..-."
    };

    const REVERSE = {};
    for (const [ch, pat] of Object.entries(MORSE)) {
      REVERSE[pat] = ch;
    }

    /* ============================================================
       CALL SIGN GENERATOR (Regions 1, 2, 3)
       ============================================================ */
    const PREFIXES = {
      1: ["F","G","I","M","DL","PA","ON","OE","OK","OM","SP","HA","HB","LA","SM","OH","YU","LZ","SV","TA","4X","5B","EA","CT","9A","S5","YO","ER"],
      2: ["K","N","W","AA","AB","AC","AD","AE","AF","AG","AI","AJ","AK","VE","VA","VO","VY","XE","TG","HP","TI","PY","PT","LU","YV"],
      3: ["JA","JE","JF","JG","JH","JI","JK","JL","HL","DS","HS","9M2","9M6","9V","VK","ZL","VU","BY","VR"]
    };

    function randItem(a) { return a[Math.floor(Math.random() * a.length)]; }
    function randDigit() { return Math.floor(Math.random() * 10).toString(); }
    function randSuffix(n) {
      const L = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      let s = "";
      for (let i = 0; i < n; i++) s += L[Math.floor(Math.random() * L.length)];
      return s;
    }

    function generateCallsign() {
      const region = [1, 2, 3][Math.floor(Math.random() * 3)];
      const prefix = randItem(PREFIXES[region]);
      const digit = randDigit();
      const suffixLen = Math.random() < 0.1 ? 1 : (Math.random() < 0.4 ? 2 : 3);
      return (prefix + digit + randSuffix(suffixLen)).toUpperCase();
    }

    /* ============================================================
       KEYER STATE & TIMING
       ============================================================ */
    let ditPressed = false;
    let dahPressed = false;
    let sending = false;
    let elementQueue = [];
    let currentPattern = "";
    let decodedText = "";
    let lastElement = null;

    let charTimer = null;

    function ditLengthSec() {
      const wpm = parseInt(document.getElementById("wpmNumber").value, 10) || 20;
      return 1.2 / wpm; // seconds per dit
    }

    function clearCharTimer() {
      if (charTimer) {
        clearTimeout(charTimer);
        charTimer = null;
      }
    }

    function scheduleCharFinalizeFromNow() {
      clearCharTimer();
      const gapSec = ditLengthSec() * 3; // standard 3-dit character gap
      charTimer = setTimeout(() => {
        if (currentPattern.length > 0) {
          const ch = REVERSE[currentPattern] || "?";
          decodedText += ch;
          currentPattern = "";
          updateDisplay();
        }
      }, gapSec * 1000);
    }

    function enqueueDit() {
      elementQueue.push(".");
    }

    function enqueueDah() {
      elementQueue.push("-");
    }

    function processPaddles() {
      if (sending) return;

      if (ditPressed && dahPressed) {
        // iambic squeeze: if nothing queued, start alternation with previous opposite or dit
        if (elementQueue.length === 0) {
          if (lastElement === ".") {
            enqueueDah();
          } else {
            enqueueDit();
          }
        }
      } else if (ditPressed) {
        if (elementQueue.length === 0) enqueueDit();
      } else if (dahPressed) {
        if (elementQueue.length === 0) enqueueDah();
      }

      if (!sending && elementQueue.length > 0) {
        sendNextElement();
      }
    }

    function sendNextElement() {
      if (elementQueue.length === 0) {
        sending = false;
        return;
      }

      sending = true;
      clearCharTimer(); // new element is starting; don't finalize previous char yet

      const el = elementQueue.shift();
      lastElement = el;
      currentPattern += el;
      updateDisplay();

      const lenSec = el === "." ? ditLengthSec() : ditLengthSec() * 3;

      startTone();

      setTimeout(() => {
        stopTone();

        // We've just finished an element; now we can schedule character finalization.
        scheduleCharFinalizeFromNow();

        // Intra-character gap of 1 dit before next element can begin.
        setTimeout(() => {
          sending = false;
          processPaddles();
        }, ditLengthSec() * 1000);

      }, lenSec * 1000);
    }

    /* ============================================================
       KEYBOARD HANDLING
       ============================================================ */
    const focusStatusEl = document.getElementById("focusStatus");
    let pageHasFocus = document.hasFocus();

    function updateFocusStatus() {
      if (pageHasFocus) {
        focusStatusEl.textContent = "Page is focused. Paddle input should be captured.";
        focusStatusEl.classList.remove("focus-warning");
        focusStatusEl.classList.add("focus-ok");
      } else {
        focusStatusEl.textContent = "Click anywhere on this page so it can receive key events.";
        focusStatusEl.classList.remove("focus-ok");
        focusStatusEl.classList.add("focus-warning");
      }
    }

    window.addEventListener("focus", () => {
      pageHasFocus = true;
      updateFocusStatus();
    });

    window.addEventListener("blur", () => {
      pageHasFocus = false;
      updateFocusStatus();
    });

    document.addEventListener("visibilitychange", () => {
      pageHasFocus = !document.hidden;
      updateFocusStatus();
    });

    document.addEventListener("keydown", (e) => {
      if (!pageHasFocus) return;
      if (e.repeat) return;

      if (e.code === "ControlLeft") {
        e.preventDefault();
        ditPressed = true;
        processPaddles();
      } else if (e.code === "ControlRight") {
        e.preventDefault();
        dahPressed = true;
        processPaddles();
      }
    });

    document.addEventListener("keyup", (e) => {
      if (e.code === "ControlLeft") {
        ditPressed = false;
      } else if (e.code === "ControlRight") {
        dahPressed = false;
      }

      if (!ditPressed && !dahPressed) {
        // Both paddles are now up; handle Mode B extra element if desired.
        const mode = document.getElementById("iambicMode").value;
        if (mode === "B" && lastElement) {
          const extra = lastElement === "." ? "-" : ".";
          elementQueue.push(extra);
          if (!sending) {
            sendNextElement();
          }
        }
      }
    });

    /* ============================================================
       DISPLAY + CALL SIGN LOGIC
       ============================================================ */
    const callsignEl = document.getElementById("callsign");
    const decodedTextEl = document.getElementById("decodedText");
    const patternEl = document.getElementById("pattern");
    const statusEl = document.getElementById("status");

    let targetCallsign = "";

    function updateDisplay() {
      decodedTextEl.textContent = decodedText;
      patternEl.innerHTML = currentPattern
        ? currentPattern
        : "<strong>Waiting for input…</strong>";

      const cleanedDecoded = decodedText.toUpperCase().replace(/\s+/g, "");
      const cleanedTarget = targetCallsign.toUpperCase().replace(/\s+/g, "");

      if (!cleanedTarget) {
        statusEl.textContent = "Send the call sign using your paddle.";
      } else if (cleanedDecoded === cleanedTarget) {
        statusEl.innerHTML = "<span class='correct'>Correct!</span> You matched the call sign.";
        // Automatically advance after a short delay
        setTimeout(() => {
            newCallsign();
        }, 800);
      } else if (cleanedDecoded.length === 0) {
        statusEl.textContent = "Send the call sign using your paddle.";
      } else {
        statusEl.innerHTML = "<span class='wrong'>Keep going…</span> You can resend the whole call if needed.";
      }
    }

    function newCallsign() {
      targetCallsign = generateCallsign();
      callsignEl.textContent = targetCallsign.replace(/0/g, "Ø");
      decodedText = "";
      currentPattern = "";
      elementQueue = [];
      lastElement = null;
      clearCharTimer();
      updateDisplay();
    }

    /* ============================================================
       UI CONTROLS
       ============================================================ */
    const wpmSlider = document.getElementById("wpmSlider");
    const wpmNumber = document.getElementById("wpmNumber");
    const stSlider = document.getElementById("stSlider");
    const stNumber = document.getElementById("stNumber");
    const nextBtn = document.getElementById("nextBtn");
    const resetBtn = document.getElementById("resetBtn");

    wpmSlider.addEventListener("input", (e) => {
      wpmNumber.value = e.target.value;
    });
    wpmNumber.addEventListener("input", (e) => {
      const v = Math.min(40, Math.max(5, parseInt(e.target.value, 10) || 20));
      wpmNumber.value = v;
      wpmSlider.value = v;
    });

    stSlider.addEventListener("input", (e) => {
      stFreq = parseFloat(e.target.value);
      stNumber.value = stFreq;

      if (osc) {
        osc.frequency.setTargetAtTime(stFreq, audioCtx.currentTime, 0.005);
      }
    });
    stNumber.addEventListener("input", (e) => {
      const stFreq = Math.min(900, Math.max(350, parseInt(e.target.value, 10) || 650));
      stNumber.value = stFreq;
      stSlider.value = stFreq;

      if (osc) {
        osc.fequency.setTargetAtTime(stFreq, audioCtx.currentTime, 0.005);
      }
    });

    nextBtn.addEventListener("click", () => {
      newCallsign();
    });

    resetBtn.addEventListener("click", () => {
      decodedText = "";
      currentPattern = "";
      elementQueue = [];
      lastElement = null;
      clearCharTimer();
      updateDisplay();
    });

    /* ============================================================
       INIT
       ============================================================ */
    updateFocusStatus();
    newCallsign();
  </script>
</body>
</html>
