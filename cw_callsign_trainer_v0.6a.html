<!-- CW Call Sign Trainer
Author: Matthew Swint, K2MAS
License: GPLv3 -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CW Call Sign Trainer with Iambic Keyer</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111827;
      color: #e5e7eb;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    header {
      text-align: center;
      padding: 1rem 1rem 0.5rem;
    }
    header h1 {
      margin: 0;
      font-size: 1.8rem;
      color: #fbbf24;
    }
    header p {
      margin: 0.3rem 0;
      color: #9ca3af;
      font-size: 0.95rem;
    }
    .panel {
      background: #020617;
      border-radius: 0.75rem;
      padding: 1.25rem 1.5rem;
      margin: 0.75rem 0;
      width: 95%;
      max-width: 850px;
      box-sizing: border-box;
      box-shadow: 0 10px 25px rgba(0,0,0,0.35);
      border: 1px solid #1f2937;
    }
    .header-panel {
      text-align: center;
    }
    .callsign {
      font-size: 3rem;
      font-weight: 700;
      letter-spacing: 0.25em;
      color: #f9fafb;
    }
    .status {
      margin-top: 0.5rem;
      font-size: 0.95rem;
      color: #9ca3af;
    }
    .correct {
      color: #22c55e;
      font-weight: 600;
    }
    .wrong {
      color: #f97316;
      font-weight: 600;
    }
    .io-value {
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 1.1rem;
      min-height: 1.4rem;
      white-space: pre-wrap;
      word-break: break-all;
      color: #e5e7eb;
    }
    .io-value strong {
      color: #fbbf24;
      font-weight: 600;
    }
    .section-title {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: #9ca3af;
      margin-bottom: 0.4rem;
    }
    .hint {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 0.3rem;
    }
    .flex-row {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
    }
    .flex-col {
      flex: 1 1 200px;
      min-width: 0;
    }
    .controls label {
      display: block;
      margin-top: 10px;
      font-size: 0.95rem;
    }
    input[type="range"] {
      width: 200px;
      vertical-align: middle;
    }
    input[type="number"] {
      width: 60px;
      margin-left: 8px;
      padding: 2px 4px;
      background: #020617;
      border: 1px solid #374151;
      color: #e5e7eb;
      border-radius: 4px;
    }
    select {
      margin-left: 8px;
      padding: 2px 4px;
      background: #020617;
      border: 1px solid #374151;
      color: #e5e7eb;
      border-radius: 4px;
    }
    .btn-row {
      margin-top: 12px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    button {
      border-radius: 9999px;
      border: 1px solid #374151;
      background: #111827;
      color: #e5e7eb;
      padding: 6px 14px;
      font-size: 0.9rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      transition: background 0.12s ease, transform 0.08s ease, box-shadow 0.1s ease;
      box-shadow: 0 4px 10px rgba(0,0,0,0.35);
    }
    button:hover {
      background: #1f2937;
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(0,0,0,0.4);
    }
    button:active {
      transform: translateY(0);
      box-shadow: 0 3px 8px rgba(0,0,0,0.3);
    }
    .primary {
      background: #22c55e;
      color: #022c22;
      border-color: #16a34a;
      box-shadow: 0 6px 16px rgba(34,197,94,0.45);
    }
    .primary:hover {
      background: #16a34a;
    }
    .focus-status {
      font-size: 0.8rem;
      margin-top: 0.35rem;
    }
    .focus-warning {
      color: #f97316;
    }
    .focus-ok {
      color: #22c55e;
    }
    footer {
      font-size: 0.75rem;
      color: #4b5563;
      padding: 0.5rem 1rem 1rem;
      text-align: center;
    }
  </style>
</head>
<body>
  <header>
    <h1>CW Call Sign Sending Trainer</h1>
    <p>Compatible with the hamradio.solutions paddle adapter.</p>
  </header>

  <div class="panel header-panel">
    <div class="section-title">Current call sign</div>
    <div id="callsign" class="callsign">Loading…</div>
    <div id="status" class="status">Send the call sign using your paddle.</div>
    <div id="focusStatus" class="focus-status focus-warning">
      Click anywhere on this page so it can receive key events.
    </div>
  </div>

  <div class="panel">
    <div class="flex-row">
      <div class="flex-col">
        <div class="section-title">Decoded text</div>
        <div id="decodedText" class="io-value"></div>
        <div class="hint">Your letters as the app decodes them.</div>
      </div>
      <div class="flex-col">
        <div class="section-title">Current Morse pattern</div>
        <div id="pattern" class="io-value"><strong>Waiting for input…</strong></div>
        <div class="hint">Dot = left paddle, Dash = right paddle.</div>
      </div>
    </div>
  </div>

  <div class="btn-row">
      <button id="nextBtn" class="primary">Next call sign</button>
      <button id="resetBtn">Reset decoded text</button>
    </div>
  </div>

  <div class="panel controls">
    <div class="flex-row">
      <div class="flex-col">
        <label>
          WPM:
          <input type="range" id="wpmSlider" min="5" max="40" value="20">
          <input type="number" id="wpmNumber" min="5" max="40" value="20">
        </label>

        <label>
          Iambic mode:
          <select id="iambicMode">
            <option value="A">Mode A</option>
            <option value="B">Mode B</option>
          </select>
        </label>

        <label>
          Sidetone (Hz):
          <input type="range" id="stSlider" min="350" max="900" value="650">
          <input type="number" id="stNumber" min="350" max="900" value="650">
        </label>

        <label>
          Sidetone volume:
          <input type="range" id="toneVolume" min="0" max="1" step="0.01" value="0.3">
        </label>
      </div>
      <div class="flex-col">
        <div class="section-title">Hints</div>
        <p style="font-size:0.85rem; color:#9ca3af; margin-top:4px;">
          • Left paddle (ControlLeft) = dit<br>
          • Right paddle (ControlRight) = dah<br>
          • Hold paddles for iambic sending (A or B).<br>
          • Adjust WPM to match your normal sending speed.
        </p>
      </div>
    </div>

  <footer>
    Made with dits and dahs by Matthew Swint, K2MAS<br />
    version 0.5a
  </footer>

  <script>
    /* ============================================================
       SIDETONE AUDIO (650 Hz default)
       ============================================================ */
    let audioCtx = null;
    let osc = null;
    let gainNode = null;
    let stFreq = 650; // default

    function ensureAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        gainNode = audioCtx.createGain();
        gainNode.gain.value = 0;
        gainNode.connect(audioCtx.destination);
      }
      if (audioCtx.state === "suspended") {
        audioCtx.resume();
      }
      if (!osc) {
        osc = audioCtx.createOscillator();
        osc.frequency.setTargetAtTime(stFreq, audioCtx.currentTime, 0.005);
        osc.type = "sine";
        osc.connect(gainNode);
        osc.start();
      }
    }

    function startTone() {
      ensureAudio();
      const vol = parseFloat(document.getElementById("toneVolume").value);
      const t = audioCtx.currentTime;
      gainNode.gain.cancelScheduledValues(t);
      gainNode.gain.setTargetAtTime(vol, t, 0.003);
    }

    function stopTone() {
      if (!audioCtx || !gainNode) return;
      const t = audioCtx.currentTime;
      gainNode.gain.cancelScheduledValues(t);
      gainNode.gain.setTargetAtTime(0, t, 0.003);
    }

    /* ============================================================
       MORSE TABLE
       ============================================================ */
    const MORSE = {
      A: ".-", B: "-...", C: "-.-.", D: "-..", E: ".", F: "..-.",
      G: "--.", H: "....", I: "..", J: ".---", K: "-.-", L: ".-..",
      M: "--", N: "-.", O: "---", P: ".--.", Q: "--.-", R: ".-.",
      S: "...", T: "-", U: "..-", V: "...-", W: ".--", X: "-..-",
      Y: "-.--", Z: "--..",
      0: "-----", 1: ".----", 2: "..---", 3: "...--", 4: "....-",
      5: ".....", 6: "-....", 7: "--...", 8: "---..", 9: "----.",
      "?": "..--..", "/": "-..-."
    };

    const REVERSE = {};
    for (const [ch, pat] of Object.entries(MORSE)) {
      REVERSE[pat] = ch;
    }

    /* ============================================================
       CALL SIGN GENERATOR (Regions 1, 2, 3)
       ============================================================ */
    const PREFIXES = {
      1: ["3A","3B6","3B7","3B8","3B9","3C","3C0","3DA","3V","3X","3Y","4J","4K","4L","4O","4P","4Q","4R","4S","4U","4W","4X","4Z","5A","5B","5C","5D","5H","5I","5J","5K","5N","5O","5R","5S","5T","5U","5V","5W","5X","5Y","5Z","6V","6W","7O","7P","7Q","7T","7U","7V","7W","7X","7Y","8Q","9A","9G","9H","9I","9J","9K","9L","9M2","9M4","9N","9Q","9R","9S","9T","9U","9V","9W","9X","9Y","9Z","A2","A3","A4","A5","A6","A7","A8","A9","B","C2","C3","C4","C5","C6","C7","C8","C9","D2","D3","D4","D5","D6","D7","D8","D9","E2","E3","E4","E5","E6","E7","E8","E9","EA","EB","EC","ED","EE","EF","EG","EH","EI","EJ","EK","EL","EM","EN","EO","EP","EQ","ER","ES","ET","EU","EV","EW","EX","EY","EZ","F","G","H2","HA","HB","HC","HD","HE","HF","HG","HH","HI","HJ","HK","HL","HM","HN","HO","HP","HQ","HR","HS","HT","HU","HV","HW","HX","HY","HZ","I","J2","J3","J4","J5","J6","J7","J8","J9","LA","LB","LC","LD","LE","LF","LG","LH","LI","LJ","LK","LL","LM","LN","LO","LP","LQ","LR","LS","LT","LU","LV","LW","LX","LY","LZ","OA","OB","OC","OD","OE","OF","OG","OH","OI","OJ","OK","OL","OM","ON","OO","OP","OQ","OR","OS","OT","OU","OV","OW","OX","OY","OZ","P2","P3","P4","P5","P6","P7","P8","P9","RA","RB","RC","RD","RE","RF","RG","RH","RI","RJ","RK","RL","RM","RN","RO","RP","RQ","RR","RS","RT","RU","RV","RW","RX","RY","RZ","S0","S2","S3","S5","S6","S7","S8","S9","TA","TB","TC","TD","TE","TF","TG","TH","TI","TJ","TK","TL","TM","TN","TO","TP","TQ","TR","TS","TT","TU","TV","TW","TX","TY","TZ","UA","UB","UC","UD","UE","UF","UG","UH","UI","UJ","UK","UL","UM","UN","UO","UP","UQ","UR","US","UT","UU","UV","UW","UX","UY","UZ","V5","V6","V7","V8","V9","YA","YB","YC","YD","YE","YF","YG","YH","YI","YJ","YK","YL","YM","YN","YO","YP","YQ","YR","YS","YT","YU","YV","YW","YX","YY","YZ","Z2","Z3","Z8","ZA","ZB","ZC","ZD","ZE","ZF","ZG","ZH","ZI","ZJ","ZK","ZL","ZM","ZN","ZO","ZP","ZQ","ZR","ZS","ZT","ZU","ZV","ZW","ZX","ZY","ZZ"],
      2: ["A","K","N","W","AA","AB","AC","AD","AE","AF","AG","AH","AI","AJ","AK","AL","KA","KB","KC","KD","KE","KF","KG","KH","KI","KJ","KK","KL","KM","KN","KO","KP","KQ","KR","KS","KT","KU","KV","KW","KX","KY","KZ","NA","NB","NC","ND","NE","NF","NG","NH","NI","NJ","NK","NL","NM","NN","NO","NP","NQ","NR","NS","NT","NU","NV","NW","NX","NY","NZ","WA","WB","WC","WD","WE","WF","WG","WH","WI","WJ","WK","WL","WM","WN","WO","WP","WQ","WR","WS","WT","WU","WV","WW","WX","WY","WZ","CF","CG","CH","CI","CJ","CK","CY","CZ","CL","CM","CO","CP","CV","CW","CX","CA","CB","CC","CD","CE","3G","HC","HK","HP","3E","3F","HR","HQ","OA","OB","OC","TG","TI","YN","V2","V3","V4","8P","8R","9Y","9Z","J3","J6","J7","J8","C6","PZ","PP","PQ","PR","PS","PT","PU","PV","PW","PX","PY","AY","AZ","YV"],
      3: ["3D2","4W","5W","6K","6L","6M","6N","6O","6P","6Q","6R","6S","6T","6U","6V","6W","6X","6Y","6Z","7J","7K","7L","7M","7N","8J","8K","8L","8M","8N","9M2","9M4","9M6","9M8","9V","A2","A3","A4","A5","A6","A7","A8","A9","AP","AQ","AR","AS","AT","AU","AV","AW","AX","AY","AZ","B","BA","BB","BC","BD","BE","BF","BG","BH","BI","BJ","BK","BL","BM","BN","BO","BP","BQ","BR","BS","BT","BU","BV","BW","BX","BY","BZ","C2","E2","H4","HL","HM","JA","JB","JC","JD","JE","JF","JG","JH","JI","JJ","JK","JL","JM","JN","JO","JP","JQ","JR","JS","JT","JU","JV","JW","JX","JY","JZ","P2","V6","V7","V8","VK","VL","VM","VN","VO","VP","VQ","VR","VS","VT","VU","VV","VW","VX","VY","VZ","YB","YC","YD","YE","YF","YG","YH","YI","YJ","YK","YL","YM","YN","YO","YP","YQ","YR","YS","YT","YU","YV","YW","YX","YY","YZ","ZK","ZL","ZM"]
    };

    function randItem(a) { return a[Math.floor(Math.random() * a.length)]; }
    function randDigit() { return Math.floor(Math.random() * 10).toString(); }
    function randSuffix(n) {
      const L = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      let s = "";
      for (let i = 0; i < n; i++) s += L[Math.floor(Math.random() * L.length)];
      return s;
    }

    function generateCallsign() {
      const region = [1, 2, 3][Math.floor(Math.random() * 3)];
      const prefix = randItem(PREFIXES[region]);
      const digit = randDigit();
      const suffixLen = Math.random() < 0.1 ? 1 : (Math.random() < 0.4 ? 2 : 3);
      return (prefix + digit + randSuffix(suffixLen)).toUpperCase();
    }

    /* ============================================================
       KEYER STATE & TIMING
       ============================================================ */
    let ditPressed = false;
    let dahPressed = false;
    let sending = false;
    let elementQueue = [];
    let currentPattern = "";
    let decodedText = "";
    let lastElement = null;

    let charTimer = null;

    function ditLengthSec() {
      const wpm = parseInt(document.getElementById("wpmNumber").value, 10) || 20;
      return 1.2 / wpm; // seconds per dit
    }

    function clearCharTimer() {
      if (charTimer) {
        clearTimeout(charTimer);
        charTimer = null;
      }
    }

    function scheduleCharFinalizeFromNow() {
      clearCharTimer();
      const gapSec = ditLengthSec() * 3; // standard 3-dit character gap
      charTimer = setTimeout(() => {
        if (currentPattern.length > 0) {
          const ch = REVERSE[currentPattern] || "?";
          decodedText += ch;
          currentPattern = "";
          updateDisplay();
        }
      }, gapSec * 1000);
    }

    function enqueueDit() {
      elementQueue.push(".");
    }

    function enqueueDah() {
      elementQueue.push("-");
    }

    function processPaddles() {
      if (sending) return;

      if (ditPressed && dahPressed) {
        // iambic squeeze: if nothing queued, start alternation with previous opposite or dit
        if (elementQueue.length === 0) {
          if (lastElement === ".") {
            enqueueDah();
          } else {
            enqueueDit();
          }
        }
      } else if (ditPressed) {
        if (elementQueue.length === 0) enqueueDit();
      } else if (dahPressed) {
        if (elementQueue.length === 0) enqueueDah();
      }

      if (!sending && elementQueue.length > 0) {
        sendNextElement();
      }
    }

    function sendNextElement() {
      if (elementQueue.length === 0) {
        sending = false;
        return;
      }

      sending = true;
      clearCharTimer(); // new element is starting; don't finalize previous char yet

      const el = elementQueue.shift();
      lastElement = el;
      currentPattern += el;
      updateDisplay();

      const lenSec = el === "." ? ditLengthSec() : ditLengthSec() * 3;

      startTone();

      setTimeout(() => {
        stopTone();

        // We've just finished an element; now we can schedule character finalization.
        scheduleCharFinalizeFromNow();

        // Intra-character gap of 1 dit before next element can begin.
        setTimeout(() => {
          sending = false;
          processPaddles();
        }, ditLengthSec() * 1000);

      }, lenSec * 1000);
    }

    /* ============================================================
       KEYBOARD HANDLING
       ============================================================ */
    const focusStatusEl = document.getElementById("focusStatus");
    let pageHasFocus = document.hasFocus();

    function updateFocusStatus() {
      if (pageHasFocus) {
        focusStatusEl.textContent = "Page is focused. Paddle input should be captured.";
        focusStatusEl.classList.remove("focus-warning");
        focusStatusEl.classList.add("focus-ok");
      } else {
        focusStatusEl.textContent = "Click anywhere on this page so it can receive key events.";
        focusStatusEl.classList.remove("focus-ok");
        focusStatusEl.classList.add("focus-warning");
      }
    }

    window.addEventListener("focus", () => {
      pageHasFocus = true;
      updateFocusStatus();
    });

    window.addEventListener("blur", () => {
      pageHasFocus = false;
      updateFocusStatus();
    });

    document.addEventListener("visibilitychange", () => {
      pageHasFocus = !document.hidden;
      updateFocusStatus();
    });

    document.addEventListener("keydown", (e) => {
      if (!pageHasFocus) return;
      if (e.repeat) return;

      if (e.code === "ControlLeft") {
        e.preventDefault();
        ditPressed = true;
        processPaddles();
      } else if (e.code === "ControlRight") {
        e.preventDefault();
        dahPressed = true;
        processPaddles();
      }
    });

    document.addEventListener("keyup", (e) => {
      if (e.code === "ControlLeft") {
        ditPressed = false;
      } else if (e.code === "ControlRight") {
        dahPressed = false;
      }

      if (!ditPressed && !dahPressed) {
        // Both paddles are now up; handle Mode B extra element if desired.
        const mode = document.getElementById("iambicMode").value;
        if (mode === "B" && lastElement) {
          const extra = lastElement === "." ? "-" : ".";
          elementQueue.push(extra);
          if (!sending) {
            sendNextElement();
          }
        }
      }
    });

    /* ============================================================
       DISPLAY + CALL SIGN LOGIC
       ============================================================ */
    const callsignEl = document.getElementById("callsign");
    const decodedTextEl = document.getElementById("decodedText");
    const patternEl = document.getElementById("pattern");
    const statusEl = document.getElementById("status");

    let targetCallsign = "";

    function updateDisplay() {
      decodedTextEl.textContent = decodedText;
      patternEl.innerHTML = currentPattern
        ? currentPattern
        : "<strong>Waiting for input…</strong>";

      const cleanedDecoded = decodedText.toUpperCase().replace(/\s+/g, "");
      const cleanedTarget = targetCallsign.toUpperCase().replace(/\s+/g, "");

      if (!cleanedTarget) {
        statusEl.textContent = "Send the call sign using your paddle.";
      } else if (cleanedDecoded === cleanedTarget) {
        statusEl.innerHTML = "<span class='correct'>Correct!</span> You matched the call sign.";
        // Automatically advance after a short delay
        setTimeout(() => {
            newCallsign();
        }, 800);
      } else if (cleanedDecoded.length === 0) {
        statusEl.textContent = "Send the call sign using your paddle.";
      } else {
        statusEl.innerHTML = "<span class='wrong'>Keep going…</span> You can resend the whole call if needed.";
      }
    }

    function newCallsign() {
      targetCallsign = generateCallsign();
      callsignEl.textContent = targetCallsign.replace(/0/g, "Ø");
      decodedText = "";
      currentPattern = "";
      elementQueue = [];
      lastElement = null;
      clearCharTimer();
      updateDisplay();
    }

    /* ============================================================
       UI CONTROLS
       ============================================================ */
    const wpmSlider = document.getElementById("wpmSlider");
    const wpmNumber = document.getElementById("wpmNumber");
    const stSlider = document.getElementById("stSlider");
    const stNumber = document.getElementById("stNumber");
    const nextBtn = document.getElementById("nextBtn");
    const resetBtn = document.getElementById("resetBtn");

    wpmSlider.addEventListener("input", (e) => {
      wpmNumber.value = e.target.value;
    });
    wpmNumber.addEventListener("input", (e) => {
      const v = Math.min(40, Math.max(5, parseInt(e.target.value, 10) || 20));
      wpmNumber.value = v;
      wpmSlider.value = v;
    });

    stSlider.addEventListener("input", (e) => {
      stFreq = parseFloat(e.target.value);
      stNumber.value = stFreq;

      if (osc) {
        osc.frequency.setTargetAtTime(stFreq, audioCtx.currentTime, 0.005);
      }
    });
    stNumber.addEventListener("input", (e) => {
      const stFreq = Math.min(900, Math.max(350, parseInt(e.target.value, 10) || 650));
      stNumber.value = stFreq;
      stSlider.value = stFreq;

      if (osc) {
        osc.fequency.setTargetAtTime(stFreq, audioCtx.currentTime, 0.005);
      }
    });

    nextBtn.addEventListener("click", () => {
      newCallsign();
    });

    resetBtn.addEventListener("click", () => {
      decodedText = "";
      currentPattern = "";
      elementQueue = [];
      lastElement = null;
      clearCharTimer();
      updateDisplay();
    });

    /* ============================================================
       INIT
       ============================================================ */
    updateFocusStatus();
    newCallsign();
  </script>
</body>
</html>
