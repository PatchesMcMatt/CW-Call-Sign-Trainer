<!-- CW Call Sign Trainer
Author: Matthew Swint, K2MAS
License: GPLv3 -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CW Call Sign Trainer with Iambic Keyer</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111827;
      color: #e5e7eb;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    header {
      text-align: center;
      padding: 1rem 1rem 0.5rem;
    }
    header h1 {
      margin: 0;
      font-size: 1.8rem;
      color: #fbbf24;
    }
    header p {
      margin: 0.3rem 0;
      color: #9ca3af;
      font-size: 0.95rem;
    }
    .panel {
      background: #020617;
      border-radius: 0.75rem;
      padding: 1.25rem 1.5rem;
      margin: 0.75rem 0;
      width: 95%;
      max-width: 850px;
      box-sizing: border-box;
      box-shadow: 0 10px 25px rgba(0,0,0,0.35);
      border: 1px solid #1f2937;
    }
    .header-panel {
      text-align: center;
    }
    .callsign {
      font-size: 3rem;
      font-weight: 700;
      letter-spacing: 0.25em;
      color: #f9fafb;
    }
    .status {
      margin-top: 0.5rem;
      font-size: 0.95rem;
      color: #9ca3af;
    }
    .correct {
      color: #22c55e;
      font-weight: 600;
    }
    .wrong {
      color: #f97316;
      font-weight: 600;
    }
    .io-value {
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 1.1rem;
      min-height: 1.4rem;
      white-space: pre-wrap;
      word-break: break-all;
      color: #e5e7eb;
    }
    .io-value strong {
      color: #fbbf24;
      font-weight: 600;
    }
    .section-title {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: #9ca3af;
      margin-bottom: 0.4rem;
    }
    .hint {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 0.3rem;
    }
    .flex-row {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
    }
    .flex-col {
      flex: 1 1 200px;
      min-width: 0;
    }
    .controls label {
      display: block;
      margin-top: 10px;
      font-size: 0.95rem;
    }
    input[type="range"] {
      width: 200px;
      vertical-align: middle;
    }
    input[type="number"] {
      width: 60px;
      margin-left: 8px;
      padding: 2px 4px;
      background: #020617;
      border: 1px solid #374151;
      color: #e5e7eb;
      border-radius: 4px;
    }
    .reset-flash {
      color: #ff4444;
      font-weight: bold;
      letter-spacing: 2px;
    }

    select {
      margin-left: 8px;
      padding: 2px 4px;
      background: #020617;
      border: 1px solid #374151;
      color: #e5e7eb;
      border-radius: 4px;
    }
    .btn-row {
      margin-top: 12px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    button {
      border-radius: 9999px;
      border: 1px solid #374151;
      background: #111827;
      color: #e5e7eb;
      padding: 6px 14px;
      font-size: 0.9rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      transition: background 0.12s ease, transform 0.08s ease, box-shadow 0.1s ease;
      box-shadow: 0 4px 10px rgba(0,0,0,0.35);
    }
    button:hover {
      background: #1f2937;
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(0,0,0,0.4);
    }
    button:active {
      transform: translateY(0);
      box-shadow: 0 3px 8px rgba(0,0,0,0.3);
    }
    .primary {
      background: #22c55e;
      color: #022c22;
      border-color: #16a34a;
      box-shadow: 0 6px 16px rgba(34,197,94,0.45);
    }
    .primary:hover {
      background: #16a34a;
    }
    .focus-status {
      font-size: 0.8rem;
      margin-top: 0.35rem;
    }
    .focus-warning {
      color: #f97316;
    }
    .focus-ok {
      color: #22c55e;
    }
    footer {
      font-size: 0.75rem;
      color: #4b5563;
      padding: 0.5rem 1rem 1rem;
      text-align: center;
    }

    /* =======================================
    LIGHT THEME OVERRIDES
    ======================================== */
    body[data-theme="light"] {
      background: #f3f4f6;
      color: #111827;
    }

    body[data-theme="light"] .panel {
      background: #ffffff;
      border-color: #d1d5db;
      box-shadow: 0 10px 25px rgba(0,0,0,0.1);
    }

    body[data-theme="light"] header p,
    body[data-theme="light"] .callsign,
    body[data-theme="light"] .io-value,
    body[data-theme="light"] .status,
    body[data-theme="light"] .section-title,
    body[data-theme="light"] footer {
      color: #4b5563;
    }

    body[data-theme="light"] input[type="number"],
    body[data-theme="light"] select {
      background: #ffffff;
      border-color: #9ca3af;
      color: #111827;
    }

    body[data-theme="light"] .primary {
      background: #22c55e;
      color: #022c22;
      border-color: #16a34a;
      box-shadow: 0 6px 16px rgba(34,197,94,0.45);
    }
    body[data-theme="light"] .primary:hover {
      background: #16a34a;
    }

    body[data-theme="light"] button {
      background: #e5e7eb;
      color: #111827;
      border-color: #9ca3af;
      box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    }

    body[data-theme="light"] button:hover {
      background: #d1d5db;
    }
  </style>
</head>
<body>
  <header>
    <h1>CW Call Sign Sending Trainer</h1>
    <p>Compatible with the hamradio.solutions VBand paddle adapter.</p>
  </header>

  <div class="panel header-panel">
    <div class="section-title">Current call sign</div>
    <div id="callsign" class="callsign">Loading…</div>
    <div id="status" class="status">Send the call sign using your paddle.</div>
    <div id="focusStatus" class="focus-status focus-warning">
      Click anywhere on this page so it can receive key events.
    </div>
  </div>

  <div class="panel">
    <div class="flex-row">
      <div class="flex-col">
        <div class="section-title">Decoded text</div>
        <div id="decodedText" class="io-value"></div>
        <div class="hint">Your characters as the app decodes them.</div>
      </div>
      <div class="flex-col">
        <div class="section-title">Current Morse pattern</div>
        <div id="pattern" class="io-value"><strong>Waiting for input…</strong></div>
        <div class="hint">Sent character elements appear here as they are sent.</div>
      </div>
    </div>
  </div>

  <div class="btn-row">
      <button id="nextBtn" class="primary">Next call sign</button>
      <button id="resetBtn">Reset decoded text</button>
    </div>
  </div>

  <div class="panel controls">
    <div class="flex-row">
      <div class="flex-col">
        <label>
          WPM (5-40):
          <input type="range" id="wpmSlider" min="5" max="40" value="20">
          <input type="number" id="wpmNumber" min="5" max="40" value="20">
        </label>

        <label>
            Call Region:
            <select id="regionSelect">
                <option value="all">All ITU Regions</option>
                <option value="us">U.S. Calls Only</option>
                <option value="1">ITU Region 1</option>
                <option value="2">ITU Region 2</option>
                <option value="3">ITU Region 3</option>
            </select>
        </label>

        <label>
          Flip Paddle:
          <select id="paddleFlip">
              <option value="off">Right Handed</option>
              <option value="on">Left Handed</option>
            </select>
        </label>

        <label>
          Iambic mode:
          <select id="iambicMode">
            <option value="A">Mode A</option>
            <option value="B">Mode B</option>
          </select>
        </label>

        <label>
          Sidetone (Hz):
          <input type="range" id="stSlider" min="350" max="900" value="650">
          <input type="number" id="stNumber" min="350" max="900" value="650">
        </label>

        <label>
          Sidetone volume:
          <input type="range" id="toneVolume" min="0" max="1" step="0.01" value="0.3">
        </label>

        <label>
          Theme
          <select id="themeMode">
            <option value="system">System</option>
            <option value="dark">Dark</option>
            <option value="light">Light</option>
          </select>
        </label>
      </div>
      <div class="flex-col">
        <div class="section-title">Hints</div>
        <p style="font-size:0.85rem; color:#9ca3af; margin-top:4px;">
          • Left paddle, left Control, and [ are interchangeable.<br>
          • Right paddle, right Control, and ] are interchangeable.<br>
          • Send EEEE to reset attempt and try again<br>
          • Hold paddles for iambic sending (A or B).<br>
          • Adjust WPM to match your desired sending speed.
        </p>
      </div>
    </div>

  <footer>
    Made with dits and dahs by Matthew Swint, K2MAS<br>
    Your settings are stored only in your browser and never sent anywhere.
  </footer>

  <script>
    /* ============================================
    SIDETONE AUDIO (650 Hz default)
    ============================================ */
    let audioCtx = null;
    let osc = null;
    let gainNode = null;
    let stFreq = 650; // default

    function ensureAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        gainNode = audioCtx.createGain();
        gainNode.gain.value = 0;
        gainNode.connect(audioCtx.destination);
      }
      if (audioCtx.state === "suspended") {
        audioCtx.resume();
      }
      if (!osc) {
        osc = audioCtx.createOscillator();
        osc.frequency.setTargetAtTime(stFreq, audioCtx.currentTime, 0.005);
        osc.type = "sine";
        osc.connect(gainNode);
        osc.start();
      }
    }

    function startTone() {
      ensureAudio();
      const vol = parseFloat(document.getElementById("toneVolume").value);
      const t = audioCtx.currentTime;
      gainNode.gain.cancelScheduledValues(t);
      gainNode.gain.setTargetAtTime(vol, t, 0.003);
    }

    function stopTone() {
      if (!audioCtx || !gainNode) return;
      const t = audioCtx.currentTime;
      gainNode.gain.cancelScheduledValues(t);
      gainNode.gain.setTargetAtTime(0, t, 0.003);
    }

    function playResetBeep() {
      const ctx = audioCtx; // reuse your existing AudioContext
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();

      osc.frequency.value = 900; // a bit higher than sidetone so it stands out
      gain.gain.value = 0.2;     // quiet, unobtrusive

      osc.connect(gain).connect(ctx.destination);

      osc.start();
      osc.stop(ctx.currentTime + 0.12); // short blip
    }


    /* ============================================
    MORSE TABLE
    ============================================ */
    const MORSE = {
      A: ".-", B: "-...", C: "-.-.", D: "-..", E: ".", F: "..-.",
      G: "--.", H: "....", I: "..", J: ".---", K: "-.-", L: ".-..",
      M: "--", N: "-.", O: "---", P: ".--.", Q: "--.-", R: ".-.",
      S: "...", T: "-", U: "..-", V: "...-", W: ".--", X: "-..-",
      Y: "-.--", Z: "--..",
      0: "-----", 1: ".----", 2: "..---", 3: "...--", 4: "....-",
      5: ".....", 6: "-....", 7: "--...", 8: "---..", 9: "----.",
      "?": "..--..", "/": "-..-."
    };

    const REVERSE = {};
    for (const [ch, pat] of Object.entries(MORSE)) {
      REVERSE[pat] = ch;
    }

    /* ============================================
    REALISTIC CALL SIGN GENERATOR (Regions 1, 2, 3)
    ============================================ */

    /* ---------------------------
    Shared helpers
    ---------------------------- */
    function randItem(a) { return a[Math.floor(Math.random() * a.length)]; }
    function randDigit() { return Math.floor(Math.random() * 10).toString(); }
    function randSuffix(n) {
      const L = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      let s = "";
      for (let i = 0; i < n; i++) s += L[Math.floor(Math.random() * L.length)];
      return s;
    }

    // Removes QRA - QUZ and SOS as suffixes for all calls
    function isForbiddenSuffix(s) {
      const upper = s.toUpperCase();
      // SOS is always forbidden
      if (upper === "SOS") return true;
      // QRA–QUZ forbidden (only applies to 3-letter suffixes)
      if (upper.length === 3 && upper[0] === "Q") {
        const second = upper[1];
        const third = upper[2];
        // R–U range for second letter
        if (second >= "R" && second <= "U") {
          // A–Z range for third letter
          if (third >= "A" && third <= "Z") {
            return true;
          }
        }
      }
      return false;
    }

    // randSafeSuffix helps generate valid suffixes
    function randSafeSuffix(n) {
      let s;
      do {
        s = randSuffix(n);
      } while (isForbiddenSuffix(s));
      return s;
    }

    // randUS2x3Suffix() fixes the problem where the suffix of a 2x3 could start with X
    function randUS2x3Suffix() {
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      const first = letters.replace("X", ""); // remove X

      let s;
      do {
        const f = first[Math.floor(Math.random() * first.length)];
        const rest = randSuffix(2);
        s = f + rest;
      } while (isForbiddenSuffix(s));

      return s;
    }

    // generateWithRules() allows custom call sign generation rules
    function generateWithRules(prefixList, defaultRuleKey) {
      const prefix = randItem(prefixList);
      const ruleKey = CALL_RULES[prefix] ? prefix : defaultRuleKey;
      return generateFromPrefixList([prefix], ruleKey);
    }

    /* ---------------------------
    PER‑COUNTRY SUFFIX RULES
    --------------------------- */
    const CALL_RULES = {

      // ---------------------------
      // REGION 1
      // ---------------------------
      // Europe (general rule)
      "EUROPE": {
        allowExtraDigit: true,
        suffixLengths: [2,3],
        suffixBias: {2:0.2, 3:0.8},
        maxTotalLength: 6
      },

      // Russia (RA–RZ, UA–UZ)
      "RUSSIA": {
        allowExtraDigit: true,
        suffixLengths: [2,3],
        suffixBias: {2:0.2, 3:0.8},
        maxTotalLength: 6
      },

      // Middle East
      "MIDDLE_EAST": {
        allowExtraDigit: true,
        suffixLengths: [2,3],
        suffixBias: {2:0.3, 3:0.7},
        maxTotalLength: 6
      },

      // Africa
      "AFRICA": {
        allowExtraDigit: true,
        suffixLengths: [2,3],
        suffixBias: {2:0.3, 3:0.7},
        maxTotalLength: 6
      },

      // ---------------------------
      // REGION 2
      // ---------------------------
      // U.S.
      "US": {
        allowExtraDigit: true,
        suffixLengths: [1,2,3],
        suffixBias: {1:0.05, 2:0.05, 3:0.90},
        maxTotalLength: 6
      },

      // Canada
      "CANADA": {
        allowExtraDigit: true,
        suffixLengths: [2,3],
        suffixBias: {2:0.3, 3:0.7},
        maxTotalLength: 6
      },

      // Mexico
      "MEXICO": {
        allowExtraDigit: true,
        suffixLengths: [2,3],
        suffixBias: {2:0.3, 3:0.7},
        maxTotalLength: 6
      },

      // Caribbean prefixes with embedded call‑area digit (NO extra digit)
      "VP2E": { allowExtraDigit: false, suffixLengths: [1,2], suffixBias: {1:0.3, 2:0.7}, maxTotalLength: 6 },
      "VP2M": { allowExtraDigit: false, suffixLengths: [1,2], suffixBias: {1:0.3, 2:0.7}, maxTotalLength: 6 },
      "VP2V": { allowExtraDigit: false, suffixLengths: [1,2], suffixBias: {1:0.3, 2:0.7}, maxTotalLength: 6 },
      "PJ2":  { allowExtraDigit: false, suffixLengths: [1,2,3], suffixBias: {1:0.1, 2:0.2, 3:0.7}, maxTotalLength: 6 },
      "PJ4":  { allowExtraDigit: false, suffixLengths: [1,2,3], suffixBias: {1:0.1, 2:0.2, 3:0.7}, maxTotalLength: 6 },
      "PJ5":  { allowExtraDigit: false, suffixLengths: [1,2],   suffixBias: {1:0.3, 2:0.7}, maxTotalLength: 6 },
      "PJ7":  { allowExtraDigit: false, suffixLengths: [1,2,3], suffixBias: {1:0.1, 2:0.2, 3:0.7}, maxTotalLength: 6 },
      "ZF2":  { allowExtraDigit: false, suffixLengths: [1,2],   suffixBias: {1:0.3, 2:0.7}, maxTotalLength: 6 },

      // Caribbean prefixes that DO require an extra digit (6Y, 8P, 8R, 9Y, 9Z)
      "CARIBBEAN": {
        allowExtraDigit: true,
        suffixLengths: [2,3],
        suffixBias: {2:0.3, 3:0.7},
        maxTotalLength: 6
      },

      // Central America
      "CENTRAL_AMERICA": {
        allowExtraDigit: true,
        suffixLengths: [2,3],
        suffixBias: {2:0.3, 3:0.7},
        maxTotalLength: 6
      },

      // South America
      "SOUTH_AMERICA": {
        allowExtraDigit: true,
        suffixLengths: [2,3],
        suffixBias: {2:0.3, 3:0.7},
        maxTotalLength: 6
      },

      // ---------------------------
      // REGION 3
      // ---------------------------
      // Japan 
      "JAPAN": {
        allowExtraDigit: true,
        suffixLengths: [2,3],
        suffixBias: {2:0.3, 3:0.7},
        maxTotalLength: 6
      },

      // China
      "CHINA": {
        allowExtraDigit: true,
        suffixLengths: [2,3],
        suffixBias: {2:0.3, 3:0.7},
        maxTotalLength: 6
      },

      // Korea
      "KOREA": {
        allowExtraDigit: true,
        suffixLengths: [2,3],
        suffixBias: {2:0.3, 3:0.7},
        maxTotalLength: 6
      },

      // SE Asia
      "SE_ASIA": {
        allowExtraDigit: true,
        suffixLengths: [2,3],
        suffixBias: {2:0.3, 3:0.7},
        maxTotalLength: 6
      },

      // Oceania
      "OCEANIA": {
        allowExtraDigit: true,
        suffixLengths: [2,3],
        suffixBias: {2:0.3, 3:0.7},
        maxTotalLength: 6
      }
    };

    /* ---------------------------
    PREFIX PICKER
    --------------------------- */
    function generateFromPrefixList(list, ruleKey) {
      const prefix = randItem(list);
      const rules = CALL_RULES[ruleKey];

      const endsWithDigit = /\d$/.test(prefix);
      const allowExtraDigit = rules.allowExtraDigit && !endsWithDigit;

      const extraDigitCount = allowExtraDigit ? 1 : 0;

      // Enforce max total length
      const maxSuffixLen = Math.max(
        1,
        rules.maxTotalLength - prefix.length - extraDigitCount
      );

      // Choose suffix length using bias
      const possible = rules.suffixLengths.filter(n => n <= maxSuffixLen);
      const r = Math.random();
      let suffixLen = possible[possible.length - 1]; // default to longest

      let acc = 0;
      for (const n of possible) {
        acc += rules.suffixBias[n] || 0;
        if (r < acc) {
          suffixLen = n;
          break;
        }
      }

      const suffix = randSafeSuffix(suffixLen);

      if (allowExtraDigit) {
        return prefix + randDigit() + suffix;
      } else {
        return prefix + suffix;
      }
    }

    /* ----------------------------------------------------
    REGION 1 — PREFIX (Europe, Russia, Middle East, Africa)
    ---------------------------------------------------- */
    // Europe
    const EUROPE = [
      "G","M",        // United Kingdom
      "F",            // France
      "DL",           // Germany
      "I",            // Italy
      "EA","EB","EC", // Spain
      "CT","CU","CR", // Portugal + Azores
      "ON","OO","OP", // Belgium
      "PA","PB","PC","PD","PE","PF","PG","PH","PI", // Netherlands
      "OE",           // Austria
      "OK","OL",      // Czech Republic
      "OM",           // Slovakia
      "SP",           // Poland
      "HA",           // Hungary
      "HB","HB0",     // Switzerland + Liechtenstein
      "OZ",           // Denmark
      "OH","OF","OG","OI","OJ", // Finland + Aland
      "SM","7S","8S","SA","SB","SC","SD","SE","SF","SG","SH","SI","SJ","SK","SL","SM","SN","SO","SP","SQ","SR", // Sweden
      "LA","LB","LC","LD","LE","LF","LG","LH","LI","LJ","LK","LL","LM","LN", // Norway
      "TF",           // Iceland
      "LX",           // Luxembourg
      "LY",           // Lithuania
      "ES",           // Estonia
      "YL",           // Latvia
      "S5",           // Slovenia
      "9A",           // Croatia
      "Z3",           // North Macedonia
      "E7",           // Bosnia
      "T7",           // San Marino
      "YO","YP","YQ","YR", // Romania
      "YU","YT","YZ", // Serbia
      "ER",           // Moldova
      "LZ",           // Bulgaria
      "SV","SW","SX","SY","SZ","J4", // Greece
      "TA","TB","TC","YM" // Turkey
    ];

    // Russia + Ex‑Soviet
    const RUSSIA = [
      "RA","RB","RC","RD","RE","RF","RG","RH","RI","RJ","RK","RL","RM","RN","RO","RP","RQ","RR","RS","RT","RU","RV","RW","RX","RY","RZ",
      "UA","UB","UC","UD","UE","UF","UG","UH","UI","UJ","UK","UL","UM","UN","UO","UP","UQ","UR","US","UT","UU","UV","UW","UX","UY","UZ"
    ];

    // Middle East
    const MIDDLE_EAST = [
      "4X","4Z",      // Israel
      "A4",           // Oman
      "A6",           // UAE
      "A7",           // Qatar
      "A9",           // Bahrain
      "HZ",           // Saudi Arabia
      "JY",           // Jordan
      "YK",           // Syria
      "EP","EQ"       // Iran
    ];

    // Africa
    const AFRICA = [
      "5H","5I",      // Tanzania
      "5N","5O",      // Nigeria
      "5T",           // Mauritania
      "5U",           // Niger
      "5V",           // Togo
      "5X",           // Uganda
      "5Z",           // Kenya
      "6V","6W",      // Senegal
      "7P",           // Lesotho
      "7Q",           // Malawi
      "7X",           // Algeria
      "9G",           // Ghana
      "9H",           // Malta
      "9J",           // Zambia
      "9L",           // Sierra Leone
      "9U",           // Burundi
      "9X",           // Rwanda
      "C5",           // Gambia
      "C9",           // Mozambique
      "D2",           // Angola
      "D4",           // Cape Verde
      "E3",           // Eritrea
      "ET",           // Ethiopia
      "FH","FR",      // Mayotte, Reunion
      "ST",           // Sudan
      "SU",           // Egypt
      "TJ",           // Cameroon
      "TL",           // Central African Republic
      "TN",           // Congo
      "TR",           // Gabon
      "TT",           // Chad
      "TU",           // Ivory Coast
      "TY",           // Benin
      "TZ",           // Mali
      "V5",           // Namibia
      "ZD7","ZD8","ZD9", // St. Helena, Ascension, Tristan da Cunha
      "ZS","ZT","ZU"  // South Africa
    ];

    // Weighted distribution (example)
    const REGION1_WEIGHTS = [
      { list: "EUROPE", weight: 60 },
      { list: "RUSSIA", weight: 20 },
      { list: "MIDDLE_EAST", weight: 10 },
      { list: "AFRICA", weight: 10 }
    ];

    function pickWeightedRegion1() {
      const total = REGION1_WEIGHTS.reduce((a,b)=>a+b.weight,0);
      let r = Math.random() * total;
      for (const entry of REGION1_WEIGHTS) {
        if (r < entry.weight) return entry.list;
        r -= entry.weight;
      }
      return "EUROPE";
    }

    function generateRegion1Call() {
      const region = pickWeightedRegion1();
      switch (region) {
        case "EUROPE": return generateFromPrefixList(EUROPE, "EUROPE");
        case "RUSSIA": return generateFromPrefixList(RUSSIA, "RUSSIA");
        case "MIDDLE_EAST": return generateFromPrefixList(MIDDLE_EAST, "MIDDLE_EAST");
        case "AFRICA": return generateFromPrefixList(AFRICA, "AFRICA");
        default: return generateFromPrefixList(EUROPE, "EUROPE");
      }
    }

    /* ---------------------------------------------------------------
    REGION 2 — PREFIX (U.S., Canada, Mexico, Caribbean, South America)
    --------------------------------------------------------------- */
    // U.S. prefixes
    const US_PRIMARY_1LETTER = ["K", "N", "W"];
    const US_PRIMARY_2LETTER = ["AA","AB","AC","AD","AE","AF","AG","AH","AI","AJ","AK","AL"];
    const US_SECONDARY = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");

    // Canada
    const CANADA = ["VA","VE","VO","VY"];

    // Mexico
    const MEXICO = ["XE","XF","XG"];

    // Central America
    const CENTRAL_AMERICA = ["HP","TI","TG","YN","YS"];

    // Caribbean
    const CARIBBEAN = [
      // Generic Caribbean prefixes (require extra digit)
      "6Y","8P","8R","9Y","9Z","HI","J3","J6","J7","J8",

      // Special DX prefixes (NO extra digit)
      "VP2E","VP2M","VP2V",
      "PJ2","PJ4","PJ5","PJ7",
      "ZF2"
    ];

    // South America
    const SOUTH_AMERICA = [
      "CP","HC","HK","OA","OB","LU","LW","PY","PP","PQ","PR","PS","PT","PU","PV","PW","PX","PZ","YV","YY"
    ];

    // Weighted distribution
    const REGION2_WEIGHTS = [
      { list: "US", weight: 60 },
      { list: "CANADA", weight: 10 },
      { list: "MEXICO", weight: 5 },
      { list: "CARIBBEAN", weight: 10 },
      { list: "CENTRAL_AMERICA", weight: 5 },
      { list: "SOUTH_AMERICA", weight: 10 }
    ];

    function pickWeightedRegion2() {
      const total = REGION2_WEIGHTS.reduce((a,b)=>a+b.weight,0);
      let r = Math.random() * total;
      for (const entry of REGION2_WEIGHTS) {
          if (r < entry.weight) return entry.list;
          r -= entry.weight;
      }
      return "US";
    }

    function generateUSCall() {
      const roll = Math.random();
      if (roll < 0.50) return randItem(US_PRIMARY_1LETTER) + randDigit() + randSafeSuffix(3); // 1×3
      if (roll < 0.80) return randItem(US_PRIMARY_1LETTER) + randItem(US_SECONDARY) + randDigit() + randUS2x3Suffix(); // 2×3
      if (roll < 0.87) return randItem(US_PRIMARY_1LETTER) + randDigit() + randSafeSuffix(2); // 1×2
      if (roll < 0.90) return randItem(US_PRIMARY_1LETTER) + randItem(US_SECONDARY) + randDigit() + randSafeSuffix(2); // 2×2
      if (roll < 0.93) return randItem(US_PRIMARY_2LETTER) + randDigit() + randSafeSuffix(2); // 2x2 (AA - AL prefixes)
      if (roll < 0.96) return randItem(US_PRIMARY_1LETTER) + randItem(US_SECONDARY) + randDigit() + randSuffix(1); // 2×1
      if (roll < 0.99) return randItem(US_PRIMARY_2LETTER) + randDigit() + randSuffix(1); // 2×1 (AA - AL prefixes)
      return randItem(US_PRIMARY_1LETTER) + randDigit() + randSuffix(1); // 1×1
    }

    function generateRegion2Call() {
      const region = pickWeightedRegion2();
      switch (region) {
          case "US": return generateUSCall();
          case "CANADA": return generateFromPrefixList(CANADA, "CANADA");
          case "MEXICO": return generateFromPrefixList(MEXICO, "MEXICO");
          case "CARIBBEAN": return generateWithRules(CARIBBEAN, "CARIBBEAN");
          case "CENTRAL_AMERICA": return generateFromPrefixList(CENTRAL_AMERICA, "CENTRAL_AMERICA");
          case "SOUTH_AMERICA": return generateFromPrefixList(SOUTH_AMERICA, "SOUTH_AMERICA");
          default: return generateUSCall();
      }
    }

    /* ---------------------------------------
    REGION 3 — PREFIX (Asia, Oceania, Pacific)
    --------------------------------------- */
    // Japan
    const JAPAN = [
      "JA","JE","JF","JG","JH","JI","JJ","JK","JL","JM","JN","JO","JP","JQ","JR","JS"
    ];

    // China
    const CHINA = [
      "B","BA","BD","BG","BH","BI"
    ];

    // Korea
    const KOREA = [
      "HL","DS","DT"
    ];

    // Southeast Asia
    const SE_ASIA = [
      "9M2","9M4","9M6", // Malaysia
      "9V",              // Singapore
      "HS","E2",         // Thailand
      "YB","YC","YD","YE","YF","YG","YH" // Indonesia
    ];

    // Oceania / Pacific
    const OCEANIA = [
      "VK","VL","VM","VN", // Australia
      "ZL","ZM",           // New Zealand
      "3D2",               // Fiji
      "H4",                // Solomon Islands
      "YJ",                // Vanuatu
      "5W",                // Samoa
      "P2"                 // Papua New Guinea
    ];

    // Weighted distribution (example)
    const REGION3_WEIGHTS = [
      { list: "JAPAN", weight: 40 },
      { list: "CHINA", weight: 15 },
      { list: "KOREA", weight: 10 },
      { list: "SE_ASIA", weight: 20 },
      { list: "OCEANIA", weight: 15 }
    ];

    function pickWeightedRegion3() {
      const total = REGION3_WEIGHTS.reduce((a,b)=>a+b.weight,0);
      let r = Math.random() * total;
      for (const entry of REGION3_WEIGHTS) {
        if (r < entry.weight) return entry.list;
        r -= entry.weight;
      }
      return "JAPAN";
    }

    function generateRegion3Call() {
      const region = pickWeightedRegion3();
      switch (region) {
        case "JAPAN": return generateFromPrefixList(JAPAN, "JAPAN");
        case "CHINA": return generateFromPrefixList(CHINA, "CHINA");
        case "KOREA": return generateFromPrefixList(KOREA, "KOREA");
        case "SE_ASIA": return generateFromPrefixList(SE_ASIA, "SE_ASIA");
        case "OCEANIA": return generateFromPrefixList(OCEANIA, "OCEANIA");
        default: return generateFromPrefixList(JAPAN, "JAPAN");
      }
    }

    /* ============================================
    MASTER GENERATOR (respects user toggle)
    ============================================ */
    function generateCallsign() {
      const regionChoice = document.getElementById("regionSelect").value;

      if (regionChoice === "us") return generateUSCall();
      if (regionChoice === "1") return generateRegion1Call();
      if (regionChoice === "2") return generateRegion2Call();
      if (regionChoice === "3") return generateRegion3Call();

      // "all"
      const r = Math.floor(Math.random() * 3) + 1;
      if (r === 1) return generateRegion1Call();
      if (r === 2) return generateRegion2Call();
      return generateRegion3Call();
    }

    /* ============================================
    KEYER STATE & TIMING
    ============================================ */
    let ditPressed = false;
    let dahPressed = false;
    let sending = false;
    let elementQueue = [];
    let currentPattern = "";
    let decodedText = "";
    let lastElement = null;
    let charTimer = null;
    let lastChars = [];

    function ditLengthSec() {
      const wpm = parseInt(document.getElementById("wpmNumber").value, 10) || 20;
      return 1.2 / wpm; // seconds per dit
    }

    function clearCharTimer() {
      if (charTimer) {
        clearTimeout(charTimer);
        charTimer = null;
      }
    }

    function scheduleCharFinalizeFromNow() {
      clearCharTimer();
      const gapSec = ditLengthSec() * 3; // standard 3-dit character gap

      charTimer = setTimeout(() => {
        if (currentPattern.length > 0) {
          const ch = REVERSE[currentPattern] || "*";

          // -----------------------------------------
          // REALISTIC RESET: E E E E (four dits)
          // -----------------------------------------
          if (ch === "E") {
            lastChars.push("E");
            if (lastChars.length > 4) lastChars.shift();

            if (lastChars.join("") === "EEEE") {
              // Clear everything
              decodedText = "";
              currentPattern = "";
              lastChars = [];

              document.getElementById("decodedText").textContent = "";

              // Audible reset cue
              playResetBeep();

              // Show RESET flash
              patternEl.innerHTML = "<strong class='reset-flash'>RESET</strong>";

              // After a short delay, restore Waiting for input…
              setTimeout(() => {
                patternEl.innerHTML = "<strong>Waiting for input…</strong>";
              }, 500);

              return; // do NOT append "E"
            }
          } else {
            // Any non-E breaks the sequence
            lastChars = [];
          }

          // -----------------------------------------
          // Normal character handling
          // -----------------------------------------
          decodedText += ch;
          currentPattern = "";
          updateDisplay();
        }
      }, gapSec * 1000);
    }

    function enqueueDit() {
      elementQueue.push(".");
    }

    function enqueueDah() {
      elementQueue.push("-");
    }

    function processPaddles() {
      if (sending) return;

      if (ditPressed && dahPressed) {
        // iambic squeeze: if nothing queued, start alternation with previous opposite or dit
        if (elementQueue.length === 0) {
          if (lastElement === ".") {
            enqueueDah();
          } else {
            enqueueDit();
          }
        }
      } else if (ditPressed) {
        if (elementQueue.length === 0) enqueueDit();
      } else if (dahPressed) {
        if (elementQueue.length === 0) enqueueDah();
      }

      if (!sending && elementQueue.length > 0) {
        sendNextElement();
      }
    }

    function sendNextElement() {
      if (elementQueue.length === 0) {
        sending = false;
        return;
      }

      sending = true;
      clearCharTimer(); // new element is starting; don't finalize previous char yet

      const el = elementQueue.shift();
      lastElement = el;
      currentPattern += el;
      updateDisplay();

      const lenSec = el === "." ? ditLengthSec() : ditLengthSec() * 3;

      startTone();

      setTimeout(() => {
        stopTone();

        // We've just finished an element; now we can schedule character finalization.
        scheduleCharFinalizeFromNow();

        // Intra-character gap of 1 dit before next element can begin.
        setTimeout(() => {
          sending = false;
          processPaddles();
        }, ditLengthSec() * 1000);

      }, lenSec * 1000);
    }

    /* ============================================
    KEYBOARD HANDLING
    ============================================ */
    const focusStatusEl = document.getElementById("focusStatus");
    let pageHasFocus = document.hasFocus();

    function updateFocusStatus() {
      if (pageHasFocus) {
        focusStatusEl.textContent = "Page is focused. Paddle input should be captured.";
        focusStatusEl.classList.remove("focus-warning");
        focusStatusEl.classList.add("focus-ok");
      } else {
        focusStatusEl.textContent = "Click anywhere on this page so it can receive key events.";
        focusStatusEl.classList.remove("focus-ok");
        focusStatusEl.classList.add("focus-warning");
      }
    }

    window.addEventListener("focus", () => {
      pageHasFocus = true;
      updateFocusStatus();
    });

    window.addEventListener("blur", () => {
      pageHasFocus = false;
      updateFocusStatus();
    });

    document.addEventListener("visibilitychange", () => {
      pageHasFocus = !document.hidden;
      updateFocusStatus();
    });

    // Obtain paddle input via VBand adpater (or keyboard left and right Control keys)
    document.addEventListener("keydown", (e) => {
      if (!pageHasFocus) return;
      if (e.repeat) return;

      const flipped = paddleFlip.value === "on";

      if (e.code === "ControlLeft") {
        e.preventDefault();
        if (!flipped) {
          ditPressed = true;
        } else {
          dahPressed = true;
        }
        processPaddles();
      } else if (e.code === "ControlRight") {
        e.preventDefault();
        if (!flipped) {
          dahPressed = true;
        } else {
          ditPressed = true;
        }
        processPaddles();
      }
    });

    document.addEventListener("keyup", (e) => {
      const flipped = paddleFlip.value === "on";

      if (e.code === "ControlLeft") {
        if (!flipped) {
          ditPressed = false;
        } else {
          dahPressed = false;
        }
      } else if (e.code === "ControlRight") {
        if (!flipped) {
          dahPressed = false;
        } else {
          ditPressed = false;
        }
      }

      if (!ditPressed && !dahPressed) {
        const mode = document.getElementById("iambicMode").value;
        if (mode === "B" && lastElement) {
          const extra = lastElement === "." ? "-" : ".";
          elementQueue.push(extra);
          if (!sending) {
            sendNextElement();
          }
        }
      }
    });

    // Allow use of [ and ] for dits and dah entry; Useful for keyboards that lack left and right Control keys
    document.addEventListener("keydown", (e) => {
      const flipped = paddleFlip.value === "on";

      if (e.key === "[") {
        if (!flipped) {
          if (!ditPressed) {
            ditPressed = true;
            processPaddles();
          }
        } else {
          if (!dahPressed) {
            dahPressed = true;
            processPaddles();
          }
        }
        e.preventDefault();
      }

      if (e.key === "]") {
        if (!flipped) {
          if (!dahPressed) {
            dahPressed = true;
            processPaddles();
          }
        } else {
          if (!ditPressed) {
            ditPressed = true;
            processPaddles();
          }
        }
        e.preventDefault();
      }
    });

    document.addEventListener("keyup", (e) => {
      const flipped = paddleFlip.value === "on";

      if (e.key === "[") {
        if (!flipped) {
          ditPressed = false;
        } else {
          dahPressed = false;
        }
        e.preventDefault();
      }

      if (e.key === "]") {
        if (!flipped) {
          dahPressed = false;
        } else {
          ditPressed = false;
        }
        e.preventDefault();
      }
    });

    /* ============================================
    DISPLAY + CALL SIGN LOGIC
    ============================================ */
    const callsignEl = document.getElementById("callsign");
    const decodedTextEl = document.getElementById("decodedText");
    const patternEl = document.getElementById("pattern");
    const statusEl = document.getElementById("status");

    let targetCallsign = "";

    function updateDisplay() {
      decodedTextEl.textContent = decodedText;
      patternEl.innerHTML = currentPattern
        ? currentPattern
        : "<strong>Waiting for input…</strong>";

      const cleanedDecoded = decodedText.toUpperCase().replace(/\s+/g, "");
      const cleanedTarget = targetCallsign.toUpperCase().replace(/\s+/g, "");

      if (!cleanedTarget) {
        document.getElementById("status").innerHTML =
          'Send the call sign using your paddle.<br><small>Send EEEE to reset your attempt.</small>';
      } else if (cleanedDecoded === cleanedTarget) {
        statusEl.innerHTML =
          "<span class='correct'>Correct!</span> You matched the call sign!";
        setTimeout(() => {
          newCallsign();
        }, 800);
      } else if (cleanedDecoded.length === 0) {
        document.getElementById("status").innerHTML =
          'Send the call sign using your paddle.<br><small>Send EEEE to reset your attempt.</small>';
      } else {
        statusEl.innerHTML =
          "<span class='wrong'>Keep going…</span>  <small>Send EEEE to reset your attempt.</small>";
      }
    }

    function newCallsign() {
      targetCallsign = generateCallsign();
      callsignEl.textContent = targetCallsign.replace(/0/g, "Ø");
      decodedText = "";
      currentPattern = "";
      elementQueue = [];
      lastElement = null;
      clearCharTimer();
      updateDisplay();
    }

    /* ============================================
    UI CONTROLS
    ============================================ */
    const wpmSlider = document.getElementById("wpmSlider");
    const wpmNumber = document.getElementById("wpmNumber");
    const stSlider = document.getElementById("stSlider");
    const stNumber = document.getElementById("stNumber");
    const nextBtn = document.getElementById("nextBtn");
    const resetBtn = document.getElementById("resetBtn");
    const regionSelect = document.getElementById("regionSelect");
    const paddleFlip = document.getElementById("paddleFlip");

    /* ------------------------------------
    LOAD SETTINGS ON STARTUP
    ------------------------------------ */
    function loadSettings() {
      const savedWpm = localStorage.getItem("cw_wpm");
      const savedTone = localStorage.getItem("cw_tone");
      const savedRegion = localStorage.getItem("cw_region");
      const savedFlip = localStorage.getItem("cw_flip");
      const savedTheme = localStorage.getItem("cw_theme");

      if (savedWpm !== null) {
        wpmSlider.value = savedWpm;
        wpmNumber.value = savedWpm;
      }

      if (savedTone !== null) {
        stSlider.value = savedTone;
        stNumber.value = savedTone;
      }

      if (savedRegion !== null) {
        regionSelect.value = savedRegion;
        regionSelect.dispatchEvent(new Event("change"));
      }

      if (savedFlip !== null) {
        paddleFlip.value = savedFlip;
        paddleFlip.dispatchEvent(new Event("change"));
      }

      if (savedTheme !== null) {
        themeMode.value = savedTheme;
        applyTheme(savedTheme);
      }
    }

    /* ------------------------------------
    EVENT LISTENERS + SAVE SETTINGS
    ------------------------------------ */

    function setupUIListeners() {
      // WPM slider → number
      wpmSlider.addEventListener("input", (e) => {
        wpmNumber.value = e.target.value;
        localStorage.setItem("cw_wpm", e.target.value);
      });

      // WPM number → slider
      wpmNumber.addEventListener("input", (e) => {
        const v = Math.min(40, Math.max(5, parseInt(e.target.value, 10) || 20));
        wpmNumber.value = v;
        wpmSlider.value = v;
        localStorage.setItem("cw_wpm", v);
      });

      // Tone slider → number
      stSlider.addEventListener("input", (e) => {
        stFreq = parseFloat(e.target.value);
        stNumber.value = stFreq;
        localStorage.setItem("cw_tone", stFreq);

        if (osc) {
          osc.frequency.setTargetAtTime(stFreq, audioCtx.currentTime, 0.005);
        }
      });

      // Tone number → slider
      stNumber.addEventListener("input", (e) => {
        const stFreq = Math.min(900, Math.max(350, parseInt(e.target.value, 10) || 650));
        stNumber.value = stFreq;
        stSlider.value = stFreq;
        localStorage.setItem("cw_tone", stFreq);

        if (osc) {
          osc.frequency.setTargetAtTime(stFreq, audioCtx.currentTime, 0.005);
        }
      });

      // Region selector
      regionSelect.addEventListener("change", () => {
        localStorage.setItem("cw_region", regionSelect.value);
        newCallsign();
      });

      // Next button
      nextBtn.addEventListener("click", () => {
        newCallsign();
      });

      // Reset button
      resetBtn.addEventListener("click", () => {
        decodedText = "";
        currentPattern = "";
        elementQueue = [];
        lastElement = null;
        clearCharTimer();
        updateDisplay();
      });

      // Paddle flip select
      paddleFlip.addEventListener("change", () => {
        localStorage.setItem("cw_flip", paddleFlip.value);
      });

      // Theme mode select
      themeMode.addEventListener("change", () => {
        const mode = themeMode.value;
        localStorage.setItem("cw_theme", mode);
        applyTheme(mode);
      });
    }

    /* ============================================
    THEME
    ============================================ */
    function applyTheme(mode) {
      if (mode === "light") {
        document.body.dataset.theme = "light";
      } else if (mode === "dark") {
        document.body.dataset.theme = "dark";
      } else {
        // system mode
        document.body.dataset.theme = window.matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "light";
      }
    }

    /* ============================================
    INIT
    ============================================ */
    window.addEventListener("DOMContentLoaded", () => {
      loadSettings();        // restore region, WPM, tone, etc.
      setupUIListeners();    // attach listeners AFTER restoring values
      updateFocusStatus();   // safe to run now
      newCallsign();         // generate first call sign using restored region
    });
  </script>
</body>
</html>