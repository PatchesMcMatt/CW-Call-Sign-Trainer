<!-- CW Call Sign Trainer
Author: Matthew Swint, K2MAS
License: GPLv3 -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CW Call Sign Trainer with Iambic Keyer</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111827;
      color: #e5e7eb;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    header {
      text-align: center;
      padding: 1rem 1rem 0.5rem;
    }
    header h1 {
      margin: 0;
      font-size: 1.8rem;
      color: #fbbf24;
    }
    header p {
      margin: 0.3rem 0;
      color: #9ca3af;
      font-size: 0.95rem;
    }
    .panel {
      background: #020617;
      border-radius: 0.75rem;
      padding: 1.25rem 1.5rem;
      margin: 0.75rem 0;
      width: 95%;
      max-width: 850px;
      box-sizing: border-box;
      box-shadow: 0 10px 25px rgba(0,0,0,0.35);
      border: 1px solid #1f2937;
    }
    .header-panel {
      text-align: center;
    }
    .callsign {
      font-size: 3rem;
      font-weight: 700;
      letter-spacing: 0.25em;
      color: #f9fafb;
    }
    .status {
      margin-top: 0.5rem;
      font-size: 0.95rem;
      color: #9ca3af;
    }
    .correct {
      color: #22c55e;
      font-weight: 600;
    }
    .wrong {
      color: #f97316;
      font-weight: 600;
    }
    .io-value {
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 1.1rem;
      min-height: 1.4rem;
      white-space: pre-wrap;
      word-break: break-all;
      color: #e5e7eb;
    }
    .io-value strong {
      color: #fbbf24;
      font-weight: 600;
    }
    .section-title {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: #9ca3af;
      margin-bottom: 0.4rem;
    }
    .hint {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 0.3rem;
    }
    .flex-row {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
    }
    .flex-col {
      flex: 1 1 200px;
      min-width: 0;
    }
    .controls label {
      display: block;
      margin-top: 10px;
      font-size: 0.95rem;
    }
    input[type="range"] {
      width: 200px;
      vertical-align: middle;
    }
    input[type="number"] {
      width: 60px;
      margin-left: 8px;
      padding: 2px 4px;
      background: #020617;
      border: 1px solid #374151;
      color: #e5e7eb;
      border-radius: 4px;
    }
    select {
      margin-left: 8px;
      padding: 2px 4px;
      background: #020617;
      border: 1px solid #374151;
      color: #e5e7eb;
      border-radius: 4px;
    }
    .btn-row {
      margin-top: 12px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    button {
      border-radius: 9999px;
      border: 1px solid #374151;
      background: #111827;
      color: #e5e7eb;
      padding: 6px 14px;
      font-size: 0.9rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      transition: background 0.12s ease, transform 0.08s ease, box-shadow 0.1s ease;
      box-shadow: 0 4px 10px rgba(0,0,0,0.35);
    }
    button:hover {
      background: #1f2937;
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(0,0,0,0.4);
    }
    button:active {
      transform: translateY(0);
      box-shadow: 0 3px 8px rgba(0,0,0,0.3);
    }
    .primary {
      background: #22c55e;
      color: #022c22;
      border-color: #16a34a;
      box-shadow: 0 6px 16px rgba(34,197,94,0.45);
    }
    .primary:hover {
      background: #16a34a;
    }
    .focus-status {
      font-size: 0.8rem;
      margin-top: 0.35rem;
    }
    .focus-warning {
      color: #f97316;
    }
    .focus-ok {
      color: #22c55e;
    }
    footer {
      font-size: 0.75rem;
      color: #4b5563;
      padding: 0.5rem 1rem 1rem;
      text-align: center;
    }
  </style>
</head>
<body>
  <header>
    <h1>CW Call Sign Sending Trainer</h1>
    <p>Compatible with the hamradio.solutions paddle adapter.</p>
  </header>

  <div class="panel header-panel">
    <div class="section-title">Current call sign</div>
    <div id="callsign" class="callsign">Loading…</div>
    <div id="status" class="status">Send the call sign using your paddle.</div>
    <div id="focusStatus" class="focus-status focus-warning">
      Click anywhere on this page so it can receive key events.
    </div>
  </div>

  <div class="panel">
    <div class="flex-row">
      <div class="flex-col">
        <div class="section-title">Decoded text</div>
        <div id="decodedText" class="io-value"></div>
        <div class="hint">Your letters as the app decodes them.</div>
      </div>
      <div class="flex-col">
        <div class="section-title">Current Morse pattern</div>
        <div id="pattern" class="io-value"><strong>Waiting for input…</strong></div>
        <div class="hint">Dot = left paddle, Dash = right paddle.</div>
      </div>
    </div>
  </div>

  <div class="btn-row">
      <button id="nextBtn" class="primary">Next call sign</button>
      <button id="resetBtn">Reset decoded text</button>
    </div>
  </div>

  <div class="panel controls">
    <div class="flex-row">
      <div class="flex-col">
        <label>
          WPM:
          <input type="range" id="wpmSlider" min="5" max="40" value="20">
          <input type="number" id="wpmNumber" min="5" max="40" value="20">
        </label>

        <label>
            Call sign region (ITU):
            <select id="regionSelect">
                <option value="all">All Regions</option>
                <option value="1">Region 1</option>
                <option value="2">Region 2</option>
                <option value="3">Region 3</option>
            </select>
        </label>

        <label>
          Iambic mode:
          <select id="iambicMode">
            <option value="A">Mode A</option>
            <option value="B">Mode B</option>
          </select>
        </label>

        <label>
          Sidetone (Hz):
          <input type="range" id="stSlider" min="350" max="900" value="650">
          <input type="number" id="stNumber" min="350" max="900" value="650">
        </label>

        <label>
          Sidetone volume:
          <input type="range" id="toneVolume" min="0" max="1" step="0.01" value="0.3">
        </label>
      </div>
      <div class="flex-col">
        <div class="section-title">Hints</div>
        <p style="font-size:0.85rem; color:#9ca3af; margin-top:4px;">
          • Left paddle (ControlLeft) = dit<br>
          • Right paddle (ControlRight) = dah<br>
          • Hold paddles for iambic sending (A or B).<br>
          • Adjust WPM to match your normal sending speed.
        </p>
      </div>
    </div>

  <footer>
    Made with dits and dahs by Matthew Swint, K2MAS
  </footer>

  <script>
    /* ============================================================
       SIDETONE AUDIO (650 Hz default)
       ============================================================ */
    let audioCtx = null;
    let osc = null;
    let gainNode = null;
    let stFreq = 650; // default

    function ensureAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        gainNode = audioCtx.createGain();
        gainNode.gain.value = 0;
        gainNode.connect(audioCtx.destination);
      }
      if (audioCtx.state === "suspended") {
        audioCtx.resume();
      }
      if (!osc) {
        osc = audioCtx.createOscillator();
        osc.frequency.setTargetAtTime(stFreq, audioCtx.currentTime, 0.005);
        osc.type = "sine";
        osc.connect(gainNode);
        osc.start();
      }
    }

    function startTone() {
      ensureAudio();
      const vol = parseFloat(document.getElementById("toneVolume").value);
      const t = audioCtx.currentTime;
      gainNode.gain.cancelScheduledValues(t);
      gainNode.gain.setTargetAtTime(vol, t, 0.003);
    }

    function stopTone() {
      if (!audioCtx || !gainNode) return;
      const t = audioCtx.currentTime;
      gainNode.gain.cancelScheduledValues(t);
      gainNode.gain.setTargetAtTime(0, t, 0.003);
    }

    /* ============================================================
       MORSE TABLE
       ============================================================ */
    const MORSE = {
      A: ".-", B: "-...", C: "-.-.", D: "-..", E: ".", F: "..-.",
      G: "--.", H: "....", I: "..", J: ".---", K: "-.-", L: ".-..",
      M: "--", N: "-.", O: "---", P: ".--.", Q: "--.-", R: ".-.",
      S: "...", T: "-", U: "..-", V: "...-", W: ".--", X: "-..-",
      Y: "-.--", Z: "--..",
      0: "-----", 1: ".----", 2: "..---", 3: "...--", 4: "....-",
      5: ".....", 6: "-....", 7: "--...", 8: "---..", 9: "----.",
      "?": "..--..", "/": "-..-."
    };

    const REVERSE = {};
    for (const [ch, pat] of Object.entries(MORSE)) {
      REVERSE[pat] = ch;
    }

    /* ============================================================
    REALISTIC CALL SIGN GENERATOR (Regions 1, 2, 3)
    ============================================================ */

    /* ---------------------------
    Shared helpers
    ---------------------------- */
    function randItem(a) { return a[Math.floor(Math.random() * a.length)]; }
    function randDigit() { return Math.floor(Math.random() * 10).toString(); }
    function randSuffix(n) {
    const L = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let s = "";
    for (let i = 0; i < n; i++) s += L[Math.floor(Math.random() * L.length)];
    return s;
    }

    // Prefixes where the digit in the prefix is already the call-area digit
    // → Do NOT add another digit after them.
    const NO_EXTRA_DIGIT_PREFIXES = new Set([
    // Region 2 Caribbean examples
    "PJ2", "PJ4", "PJ5", "PJ7",
    "VP2E", "VP2M", "VP2V","VP5",
    "ZF2",
    "9M2","9M6"

    // You can add more here as you refine behavior:
    // e.g., "ZB2", "ZD8", etc., if needed.
    ]);


    /* ============================================================
    REGION 2 — REALISTIC (U.S., Canada, Mexico, Caribbean, SA)
    ============================================================ */

    // U.S. prefixes
    const US_PRIMARY = ["K", "N", "W"];
    const US_SECONDARY = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");

    // Canada
    const CANADA = ["VA","VE","VO","VY"];

    // Mexico
    const MEXICO = ["XE","XF","XG"];

    // Central America
    const CENTRAL_AMERICA = ["HP","TI","TG","YN","YS"];

    // Caribbean
    const CARIBBEAN = [
    "6Y","8P","8R","9Y","9Z","HI","J3","J6","J7","J8","ZF"
    ];

    // South America
    const SOUTH_AMERICA = [
    "CP","HC","HK","OA","OB","LU","LW","PY","PP","PQ","PR","PS","PT","PU","PV","PW","PX","PZ","YV","YY"
    ];

    // Weighted distribution
    const REGION2_WEIGHTS = [
    { list: "US", weight: 60 },
    { list: "CANADA", weight: 10 },
    { list: "MEXICO", weight: 5 },
    { list: "CARIBBEAN", weight: 10 },
    { list: "CENTRAL_AMERICA", weight: 5 },
    { list: "SOUTH_AMERICA", weight: 10 }
    ];

    function pickWeightedRegion2() {
    const total = REGION2_WEIGHTS.reduce((a,b)=>a+b.weight,0);
    let r = Math.random() * total;
    for (const entry of REGION2_WEIGHTS) {
        if (r < entry.weight) return entry.list;
        r -= entry.weight;
    }
    return "US";
    }

    function generateUSCall() {
    const roll = Math.random();

    if (roll < 0.60) return randItem(US_PRIMARY) + randDigit() + randSuffix(3); // 1×3
    if (roll < 0.90) return randItem(US_PRIMARY) + randItem(US_SECONDARY) + randDigit() + randSuffix(3); // 2×3
    if (roll < 0.95) return randItem(US_PRIMARY) + randDigit() + randSuffix(2); // 1×2
    if (roll < 0.98) return randItem(US_PRIMARY) + randItem(US_SECONDARY) + randDigit() + randSuffix(1); // 2×1
    return randItem(US_PRIMARY) + randDigit() + randSuffix(1); // 1×1
    }

    function generateFromPrefixList(list) {
    const prefix = randItem(list);
    const suffixLen = Math.random() < 0.2 ? 2 : 3;
    const endsWithDigit = /\d$/.test(prefix);

    if (endsWithDigit) {
    // Prefix already includes the call-area digit
    // → NO extra digit
    return prefix + randSuffix(suffixLen);
    } else {
    // Prefix does NOT include the call-area digit
    // → ADD a digit
    return prefix + randDigit() + randSuffix(suffixLen);
    }
    }


    function generateRegion2Call() {
    const region = pickWeightedRegion2();
    switch (region) {
        case "US": return generateUSCall();
        case "CANADA": return generateFromPrefixList(CANADA);
        case "MEXICO": return generateFromPrefixList(MEXICO);
        case "CARIBBEAN": return generateFromPrefixList(CARIBBEAN);
        case "CENTRAL_AMERICA": return generateFromPrefixList(CENTRAL_AMERICA);
        case "SOUTH_AMERICA": return generateFromPrefixList(SOUTH_AMERICA);
        default: return generateUSCall();
    }
    }

    /* ============================================================
    REGION 1 — REALISTIC (Europe, Africa, Middle East)
    ============================================================ */

    const REGION1_PREFIXES = [
    "G","M","F","DL","PA","ON","OE","OK","OM","SP","HA","HB","LA","SM","OH","YU","LZ","SV","TA","4X","5B",
    "EA","CT","9A","S5","YO","ER","ZS","ZR","ZB","ZC","ZD","ZA","Z3","Z2","LX","LY","OZ","OY","TF","EI"
    ];

    function generateRegion1Call() {
    const prefix = randItem(REGION1_PREFIXES);
    const digit = randDigit();
    const suffix = randSuffix(Math.random() < 0.2 ? 2 : 3);
    return prefix + digit + suffix;
    }

    /* ============================================================
    REGION 3 — REALISTIC (Asia-Pacific)
    ============================================================ */

    const REGION3_PREFIXES = [
    "JA","JE","JF","JG","JH","JI","JK","JL","JM","HL","DS","HS","9V","VK","ZL","YB","YC","YD","YE","YF","YG","YH","VU","VR","P2","V6","V7","V8"
    ];

    function generateRegion3Call() {
    const prefix = randItem(REGION3_PREFIXES);
    const digit = randDigit();
    const suffix = randSuffix(Math.random() < 0.2 ? 2 : 3);
    return prefix + digit + suffix;
    }

    /* ============================================================
    MASTER GENERATOR (respects user toggle)
    ============================================================ */
    function generateCallsign() {
    const regionChoice = document.getElementById("regionSelect").value;

    let region;
    if (regionChoice === "all") {
        region = [1,2,3][Math.floor(Math.random() * 3)];
    } else {
        region = parseInt(regionChoice, 10);
    }

    switch (region) {
        case 1: return generateRegion1Call();
        case 2: return generateRegion2Call();
        case 3: return generateRegion3Call();
        default: return generateRegion2Call();
    }
    }

    /* ============================================================
       KEYER STATE & TIMING
       ============================================================ */
    let ditPressed = false;
    let dahPressed = false;
    let sending = false;
    let elementQueue = [];
    let currentPattern = "";
    let decodedText = "";
    let lastElement = null;

    let charTimer = null;

    function ditLengthSec() {
      const wpm = parseInt(document.getElementById("wpmNumber").value, 10) || 20;
      return 1.2 / wpm; // seconds per dit
    }

    function clearCharTimer() {
      if (charTimer) {
        clearTimeout(charTimer);
        charTimer = null;
      }
    }

    function scheduleCharFinalizeFromNow() {
      clearCharTimer();
      const gapSec = ditLengthSec() * 3; // standard 3-dit character gap
      charTimer = setTimeout(() => {
        if (currentPattern.length > 0) {
          const ch = REVERSE[currentPattern] || "?";
          decodedText += ch;
          currentPattern = "";
          updateDisplay();
        }
      }, gapSec * 1000);
    }

    function enqueueDit() {
      elementQueue.push(".");
    }

    function enqueueDah() {
      elementQueue.push("-");
    }

    function processPaddles() {
      if (sending) return;

      if (ditPressed && dahPressed) {
        // iambic squeeze: if nothing queued, start alternation with previous opposite or dit
        if (elementQueue.length === 0) {
          if (lastElement === ".") {
            enqueueDah();
          } else {
            enqueueDit();
          }
        }
      } else if (ditPressed) {
        if (elementQueue.length === 0) enqueueDit();
      } else if (dahPressed) {
        if (elementQueue.length === 0) enqueueDah();
      }

      if (!sending && elementQueue.length > 0) {
        sendNextElement();
      }
    }

    function sendNextElement() {
      if (elementQueue.length === 0) {
        sending = false;
        return;
      }

      sending = true;
      clearCharTimer(); // new element is starting; don't finalize previous char yet

      const el = elementQueue.shift();
      lastElement = el;
      currentPattern += el;
      updateDisplay();

      const lenSec = el === "." ? ditLengthSec() : ditLengthSec() * 3;

      startTone();

      setTimeout(() => {
        stopTone();

        // We've just finished an element; now we can schedule character finalization.
        scheduleCharFinalizeFromNow();

        // Intra-character gap of 1 dit before next element can begin.
        setTimeout(() => {
          sending = false;
          processPaddles();
        }, ditLengthSec() * 1000);

      }, lenSec * 1000);
    }

    /* ============================================================
       KEYBOARD HANDLING
       ============================================================ */
    const focusStatusEl = document.getElementById("focusStatus");
    let pageHasFocus = document.hasFocus();

    function updateFocusStatus() {
      if (pageHasFocus) {
        focusStatusEl.textContent = "Page is focused. Paddle input should be captured.";
        focusStatusEl.classList.remove("focus-warning");
        focusStatusEl.classList.add("focus-ok");
      } else {
        focusStatusEl.textContent = "Click anywhere on this page so it can receive key events.";
        focusStatusEl.classList.remove("focus-ok");
        focusStatusEl.classList.add("focus-warning");
      }
    }

    window.addEventListener("focus", () => {
      pageHasFocus = true;
      updateFocusStatus();
    });

    window.addEventListener("blur", () => {
      pageHasFocus = false;
      updateFocusStatus();
    });

    document.addEventListener("visibilitychange", () => {
      pageHasFocus = !document.hidden;
      updateFocusStatus();
    });

    document.addEventListener("keydown", (e) => {
      if (!pageHasFocus) return;
      if (e.repeat) return;

      if (e.code === "ControlLeft") {
        e.preventDefault();
        ditPressed = true;
        processPaddles();
      } else if (e.code === "ControlRight") {
        e.preventDefault();
        dahPressed = true;
        processPaddles();
      }
    });

    document.addEventListener("keyup", (e) => {
      if (e.code === "ControlLeft") {
        ditPressed = false;
      } else if (e.code === "ControlRight") {
        dahPressed = false;
      }

      if (!ditPressed && !dahPressed) {
        // Both paddles are now up; handle Mode B extra element if desired.
        const mode = document.getElementById("iambicMode").value;
        if (mode === "B" && lastElement) {
          const extra = lastElement === "." ? "-" : ".";
          elementQueue.push(extra);
          if (!sending) {
            sendNextElement();
          }
        }
      }
    });

    /* ============================================================
       DISPLAY + CALL SIGN LOGIC
       ============================================================ */
    const callsignEl = document.getElementById("callsign");
    const decodedTextEl = document.getElementById("decodedText");
    const patternEl = document.getElementById("pattern");
    const statusEl = document.getElementById("status");

    let targetCallsign = "";

    function updateDisplay() {
      decodedTextEl.textContent = decodedText;
      patternEl.innerHTML = currentPattern
        ? currentPattern
        : "<strong>Waiting for input…</strong>";

      const cleanedDecoded = decodedText.toUpperCase().replace(/\s+/g, "");
      const cleanedTarget = targetCallsign.toUpperCase().replace(/\s+/g, "");

      if (!cleanedTarget) {
        statusEl.textContent = "Send the call sign using your paddle.";
      } else if (cleanedDecoded === cleanedTarget) {
        statusEl.innerHTML = "<span class='correct'>Correct!</span> You matched the call sign.";
        // Automatically advance after a short delay
        setTimeout(() => {
            newCallsign();
        }, 800);
      } else if (cleanedDecoded.length === 0) {
        statusEl.textContent = "Send the call sign using your paddle.";
      } else {
        statusEl.innerHTML = "<span class='wrong'>Keep going…</span> You can resend the whole call if needed.";
      }
    }

    function newCallsign() {
      targetCallsign = generateCallsign();
      callsignEl.textContent = targetCallsign.replace(/0/g, "Ø");
      decodedText = "";
      currentPattern = "";
      elementQueue = [];
      lastElement = null;
      clearCharTimer();
      updateDisplay();
    }

    /* ============================================================
       UI CONTROLS
       ============================================================ */
    const wpmSlider = document.getElementById("wpmSlider");
    const wpmNumber = document.getElementById("wpmNumber");
    const stSlider = document.getElementById("stSlider");
    const stNumber = document.getElementById("stNumber");
    const nextBtn = document.getElementById("nextBtn");
    const resetBtn = document.getElementById("resetBtn");
    const regionSelect = document.getElementById("regionSelect");

    wpmSlider.addEventListener("input", (e) => {
      wpmNumber.value = e.target.value;
    });
    wpmNumber.addEventListener("input", (e) => {
      const v = Math.min(40, Math.max(5, parseInt(e.target.value, 10) || 20));
      wpmNumber.value = v;
      wpmSlider.value = v;
    });

    stSlider.addEventListener("input", (e) => {
      stFreq = parseFloat(e.target.value);
      stNumber.value = stFreq;

      if (osc) {
        osc.frequency.setTargetAtTime(stFreq, audioCtx.currentTime, 0.005);
      }
    });
    stNumber.addEventListener("input", (e) => {
      const stFreq = Math.min(900, Math.max(350, parseInt(e.target.value, 10) || 650));
      stNumber.value = stFreq;
      stSlider.value = stFreq;

      if (osc) {
        osc.fequency.setTargetAtTime(stFreq, audioCtx.currentTime, 0.005);
      }
    });

    nextBtn.addEventListener("click", () => {
      newCallsign();
    });

    resetBtn.addEventListener("click", () => {
      decodedText = "";
      currentPattern = "";
      elementQueue = [];
      lastElement = null;
      clearCharTimer();
      updateDisplay();
    });

    regionSelect.addEventListener("change", () => {
    // Immediately load a new call sign when the user changes regions
    newCallsign();
    });


    /* ============================================================
       INIT
       ============================================================ */
    updateFocusStatus();
    newCallsign();
  </script>
</body>
</html>
